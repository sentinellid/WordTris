<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WordTris</title>
    <style>
        body { background: #111; color: #eee; font-family: sans-serif; text-align: center; margin: 0; padding-bottom: 90px; }
        #game { margin: 10px auto 5px; display: inline-grid; grid-template-columns: repeat(10, 32px); grid-auto-rows: 32px; gap: 2px; background: #2a2a2a; padding: 2px; border: 3px solid #555; border-radius: 8px; }
        .cell { background: #383838; display: flex; align-items: center; justify-content: center; font: 600 15px monospace; overflow: hidden; user-select: none; border-radius: 5px; box-shadow: inset 0 0 4px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.3); transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out; }
        .filled { background: linear-gradient(145deg, #3ab0c0, #2f8a9a); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.2), inset 0 -1px 1px rgba(0,0,0,0.1), 0 2px 3px rgba(0,0,0,0.4); }
        .joker-cell { background: linear-gradient(145deg, #e04040, #b30000); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 2px 3px rgba(0,0,0,0.5), 0 0 6px rgba(255, 80, 80, 0.6); }
        .bomb-cell { background: linear-gradient(145deg, #555, #222); color: #ffcc00; font-size: 20px; border: 2px outset #777; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 3px 5px rgba(0,0,0,0.6), 0 0 10px rgba(255, 165, 0, 0.7); }
        .cell.clearing { animation: cellClearAnimation 0.5s forwards; position: relative; z-index: 100; }
        @keyframes cellClearAnimation { 0% { transform: scale(1.0); opacity: 1; background-color: #ffdd40; box-shadow: 0 0 15px #ffdd40; } 50% { transform: scale(1.2); opacity: 0.8; } 100% { transform: scale(0.3); opacity: 0; background-color: transparent; box-shadow: none; } }
        .piece-moved-feedback { outline: 1px solid rgba(255, 255, 0, 0.7); transition: outline 0.05s linear; }
        #info { margin: 8px; font-size: 16px; line-height: 1.2; }
        #vowel-selection { display: none; margin-top: 10px; font-size: 18px; }
        .vowel { cursor: pointer; display: inline-block; padding: 10px; margin: 5px; background: #666; border-radius: 5px; color: white; box-shadow: 0 2px 3px rgba(0,0,0,0.3); }
        .vowel:hover { background: #888; transform: translateY(-1px); }
        .vowel:active { transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }
        span.val { font-weight: bold; color: #7f7; }
        #last-word-display { margin-top: 5px; font-size: 16px; color: #ccc; min-height: 2.5em; line-height: 1.3em; }
        #last-word-display .val { color: #fa0; }
        
        /* Timer per la selezione vocale */
        #vowel-timer-container {
            width: 200px;
            height: 10px;
            background: #333;
            margin: 15px auto 5px;
            border-radius: 5px;
            overflow: hidden;
            display: none;
        }
        #vowel-timer {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #2a8, #fa0 40%, #f50 70%, #f00);
            border-radius: 5px;
            transition: width linear;
        }
        
        /* Indicatore di feedback audio */
        #sound-indicator { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 5px 10px; border-radius: 5px; font-size: 12px; opacity: 0; transition: opacity 0.2s ease; }
        #sound-indicator.active { opacity: 1; }
        
        /* Controlli audio */
        #audio-controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }
        #audio-controls button {
            background: #444;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            min-width: 80px;
        }
        #audio-controls button:hover {
            background: #555;
        }
        #audio-controls button.active {
            background: #2a8;
        }
        #audio-controls .volume-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #audio-controls .volume-control input {
            width: 80px;
        }
        .audio-label {
            color: #aaa;
            font-size: 12px;
            margin-right: 5px;
        }
        
        /* Stato di caricamento audio */
        #audio-loading {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #ff6;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        #audio-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Stile per l'overlay di avvio */
        #audio-start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        #audio-start-overlay h2 {
            font-size: 42px;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(255,255,255,0.2);
        }
        #audio-start-overlay p {
            font-size: 18px;
            max-width: 500px;
            text-align: center;
            margin-bottom: 30px;
            line-height: 1.4;
        }
        
        /* NUOVO STILE PER IL LOGO E PULSANTE SINGOLO */
        #audio-start-overlay .start-logo {
            max-width: 300px;
            height: auto;
            margin-bottom: 20px;
        }
        
        #start-game-button {
            padding: 12px 24px;
            margin: 20px 0;
            font-size: 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            font-weight: bold;
            background: linear-gradient(145deg, #3ab0c0, #2a8);
            color: white;
        }
        
        #start-game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #start-game-button:active {
            transform: translateY(0);
        }

        /* NUOVI STILI PER CONTROLLI TOUCH - OTTIMIZZATI */
        #touch-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 5px 0;
            background: rgba(20, 20, 20, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            box-shadow: 0 -3px 10px rgba(0,0,0,0.4);
        }

        .touch-button {
            width: 60px;
            height: 60px;
            background: rgba(60, 60, 60, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            transition: all 0.1s ease;
        }

        .touch-button:active {
            background: rgba(100, 100, 100, 0.9);
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }

        /* Media queries per dispositivi mobili */
        @media (max-width: 768px) {
            #game {
                grid-template-columns: repeat(10, 28px);
                grid-auto-rows: 28px;
                gap: 1px;
                margin-top: 5px;
            }
            
            .cell {
                font-size: 12px;
            }
            
            .touch-button {
                width: 55px;
                height: 55px;
                font-size: 20px;
            }
            
            #audio-controls {
                flex-wrap: wrap;
                max-width: 200px;
                justify-content: center;
            }
            
            #audio-controls .volume-control {
                flex-basis: 100%;
                justify-content: center;
                margin-top: 5px;
            }
            
            #info {
                margin: 5px;
                font-size: 14px;
            }
            
            #last-word-display {
                font-size: 14px;
                min-height: 2.2em;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding-bottom: 80px;
            }
            
            #game {
                grid-template-columns: repeat(10, 24px);
                grid-auto-rows: 24px;
                margin-top: 3px;
            }
            
            .cell {
                font-size: 10px;
            }
            
            .touch-button {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
            
            #touch-controls {
                padding: 3px 0;
            }
        }

        /* Nasconde i controlli touch quando è disponibile un mouse */
        @media (hover: hover) and (pointer: fine) {
            #touch-controls {
                display: none;
            }
            
            body {
                padding-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Overlay per l'avvio dell'audio -->
    <div id="audio-start-overlay">
        <img src="img/logo.png" alt="WordTris Logo" class="start-logo">
        <h2>WordTris</h2>
        <p>Un gioco di parole ispirato a Tetris. Componi parole italiane usando le sillabe che cadono!</p>
        <button id="start-game-button">Inizia</button>
    </div>

    <div id="game"></div>
    <div id="info">Punti <span id="score" class="val">0</span> · Parole <span id="words" class="val">0</span> · Pezzi <span id="pieces" class="val">0</span></div>
    <div id="last-word-display">Ultima Parola: <span id="last-word-val" class="val">---</span></div>
    
    <div id="vowel-timer-container">
        <div id="vowel-timer"></div>
    </div>
    <div id="vowel-selection">Scegli una vocale (o premi A,E,I,O,U): <div class="vowel" data-vowel="A">A</div><div class="vowel" data-vowel="E">E</div><div class="vowel" data-vowel="I">I</div><div class="vowel" data-vowel="O">O</div><div class="vowel" data-vowel="U">U</div></div>
    
    <div id="sound-indicator">♪</div>
    <div id="audio-loading">Caricamento audio...</div>
    
    <!-- Controlli audio -->
    <div id="audio-controls">
        <button id="toggle-music" class="active">Musica: ON</button>
        <div class="volume-control">
            <span class="audio-label">Volume:</span>
            <input type="range" id="music-volume" min="0" max="100" value="30">
        </div>
        <div class="volume-control">
            <span class="audio-label">Effetti:</span>
            <input type="range" id="sfx-volume" min="0" max="100" value="70">
        </div>
    </div>
    
    <!-- Controlli touch per dispositivi mobili migliorati -->
    <div id="touch-controls">
        <div class="touch-button" id="touch-left">⬅️</div>
        <div class="touch-button" id="touch-rotate">🔄</div>
        <div class="touch-button" id="touch-right">➡️</div>
        <div class="touch-button" id="touch-down">⬇️</div>
    </div>
    
    <!-- Audio background nascosto -->
    <audio id="background-music" loop preload="auto">
        <source src="audio/background_music.mp3" type="audio/mp3">
    </audio>
    
    <!-- Audio hurry-up per la scelta vocale -->
    <audio id="hurry-up-sound" preload="auto">
        <source src="audio/hurry-up.mp3" type="audio/mp3">
    </audio>
    
    <!-- Audio per l'esplosione del tetramino -->
    <audio id="explode-sound" preload="auto">
        <source src="audio/explode.mp3" type="audio/mp3">
    </audio>
    
<script>
    // Riduzione di una riga: ROWS passa da 20 a 19
    const COLS = 10, ROWS = 19, START_DROP = 900, VOWEL_TIMEOUT = 3000, VOWEL_CHOICE_PROBABILITY = 0.3, ANIMATION_CLEAR_DURATION = 500;
    
    // --- MODIFICA: Sistema audio completo con musica di sottofondo MP3 ---
    const AudioSystem = {
        audioContext: null,
        backgroundMusic: document.getElementById('background-music'),
        hurryUpSound: document.getElementById('hurry-up-sound'),
        explodeSound: document.getElementById('explode-sound'),
        sfxGainNode: null,
        backgroundMusicActive: true,
        backgroundMusicLoaded: false,
        
        // Impostazioni suoni
        sounds: {
            drop: { freqs: [220, 165], durations: [0.05, 0.1] },
            selectVowel: { freqs: [440, 660], durations: [0.1, 0.1] },
            word: { freqs: [440, 493, 523, 587], durations: [0.08, 0.08, 0.08, 0.2] },
            // Nuovo effetto esplosione bomba migliorato
            bombExplosion: { 
                custom: true, 
                generate: function(audioContext, gainNode) {
                    // Creiamo un effetto più simile a un'esplosione reale
                    const duration = 1.2;
                    const now = audioContext.currentTime;
                    
                    // Suono 1: Boom basso
                    const boom = audioContext.createOscillator();
                    const boomGain = audioContext.createGain();
                    boom.type = 'sawtooth';
                    boom.frequency.setValueAtTime(120, now);
                    boom.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                    boomGain.gain.setValueAtTime(0.01, now);
                    boomGain.gain.exponentialRampToValueAtTime(0.7, now + 0.05);
                    boomGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    boom.connect(boomGain);
                    boomGain.connect(gainNode);
                    boom.start(now);
                    boom.stop(now + duration);
                    
                    // Suono 2: Rumore esplosione
                    const bufferSize = audioContext.sampleRate * 1.5;
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    // Generazione del rumore bianco
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    
                    // Suono "scoppio"
                    const noise = audioContext.createBufferSource();
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    
                    noise.buffer = noiseBuffer;
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.setValueAtTime(8000, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(800, now + 0.6);
                    noiseGain.gain.setValueAtTime(0.01, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.25, now + 0.05);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(gainNode);
                    
                    noise.start(now);
                    noise.stop(now + duration);
                    
                    // Suono 3: Riverbero post-esplosione
                    setTimeout(() => {
                        const reverb = audioContext.createOscillator();
                        const reverbGain = audioContext.createGain();
                        const reverbFilter = audioContext.createBiquadFilter();
                        
                        reverb.type = 'sine';
                        reverb.frequency.setValueAtTime(400, now + 0.1);
                        reverb.frequency.exponentialRampToValueAtTime(100, now + 1.0);
                        
                        reverbFilter.type = 'bandpass';
                        reverbFilter.frequency.value = 200;
                        reverbFilter.Q.value = 3;
                        
                        reverbGain.gain.setValueAtTime(0.05, now + 0.1);
                        reverbGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                        
                        reverb.connect(reverbFilter);
                        reverbFilter.connect(reverbGain);
                        reverbGain.connect(gainNode);
                        
                        reverb.start(now + 0.1);
                        reverb.stop(now + duration);
                    }, 100);
                }
            }
        },
        
        initialize() {
            try {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Crea i nodi di guadagno per effetti sonori
                    this.sfxGainNode = this.audioContext.createGain();
                    this.sfxGainNode.gain.value = 0.7; // Volume iniziale SFX (70%)
                    this.sfxGainNode.connect(this.audioContext.destination);
                    
                    // Gestione della musica di sottofondo
                    this.initBackgroundMusic();
                    
                    // Inizializza i controlli dell'interfaccia
                    this.setupUIControls();
                }
                console.log("Sistema audio inizializzato");
            } catch (e) {
                console.error("Errore inizializzazione audio:", e);
            }
        },
        
        setupUIControls() {
            // Toggle musica
            const musicToggle = document.getElementById('toggle-music');
            if (musicToggle) {
                musicToggle.addEventListener('click', () => {
                    this.toggleBackgroundMusic();
                    musicToggle.textContent = this.backgroundMusicActive ? 'Musica: ON' : 'Musica: OFF';
                    musicToggle.className = this.backgroundMusicActive ? 'active' : '';
                });
            }
            
            // Controllo volume musica
            const musicVolumeSlider = document.getElementById('music-volume');
            if (musicVolumeSlider&&this.backgroundMusic) {
                // Impedire che le frecce cambino il volume quando il focus è sugli slider
                musicVolumeSlider.addEventListener('keydown', (e) => {
                    if (e.code === "ArrowLeft" || e.code === "ArrowRight" || 
                        e.code === "ArrowUp" || e.code === "ArrowDown") {
                        e.stopPropagation();
                    }
                });
                
                musicVolumeSlider.addEventListener('input', (e) => {
                    this.backgroundMusic.volume = parseInt(e.target.value) / 100;
                });
                
                // Imposta il volume iniziale
                this.backgroundMusic.volume = parseInt(musicVolumeSlider.value) / 100;
            }
            
            // Controllo volume effetti
            const sfxVolumeSlider = document.getElementById('sfx-volume');
            if (sfxVolumeSlider) {
                // Impedire che le frecce cambino il volume quando il focus è sugli slider
                sfxVolumeSlider.addEventListener('keydown', (e) => {
                    if (e.code === "ArrowLeft" || e.code === "ArrowRight" || 
                        e.code === "ArrowUp" || e.code === "ArrowDown") {
                        e.stopPropagation();
                    }
                });
                
                sfxVolumeSlider.addEventListener('input', (e) => {
                    if (this.sfxGainNode) {
                        this.sfxGainNode.gain.value = parseInt(e.target.value) / 100;
                    }
                    
                    // Aggiorna anche il volume del suono hurry-up
                    if (this.hurryUpSound) {
                        this.hurryUpSound.volume = parseInt(e.target.value) / 100;
                    }
                    
                    // Aggiorna anche il volume del suono explode
                    if (this.explodeSound) {
                        this.explodeSound.volume = parseInt(e.target.value) / 100;
                    }
                });
                
                // Imposta il volume iniziale per hurry-up
                if (this.hurryUpSound) {
                    this.hurryUpSound.volume = parseInt(sfxVolumeSlider.value) / 100;
                }
                
                // Imposta il volume iniziale per explode
                if (this.explodeSound) {
                    this.explodeSound.volume = parseInt(sfxVolumeSlider.value) / 100;
                }
            }
            
            // AGGIUNTA: Rimuoviamo il focus dagli slider dopo l'interazione
            const volumeControls = document.querySelectorAll('#audio-controls input[type="range"]');
            volumeControls.forEach(control => {
                control.addEventListener('change', () => {
                    control.blur(); // Rimuovi il focus dopo aver modificato il valore
                });
                
                // Rimuovi il focus anche dopo il click
                control.addEventListener('click', () => {
                    setTimeout(() => control.blur(), 150);
                });
            });
        },
        
        initBackgroundMusic() {
            if (!this.backgroundMusic) {
                console.error("Elemento audio per la musica di sottofondo non trovato");
                return;
            }
            
            // Mostra indicatore di caricamento
            const loadingIndicator = document.getElementById('audio-loading');
            
            // Gestisci eventi di caricamento audio
            this.backgroundMusic.addEventListener('canplaythrough', () => {
                console.log("Musica di sottofondo caricata");
                this.backgroundMusicLoaded = true;
                
                if (loadingIndicator) {
                    loadingIndicator.classList.add('hidden');
                }
                
                // Avvia la riproduzione se attivo
                if (this.backgroundMusicActive) {
                    this.playBackgroundMusic();
                }
            });
            
            this.backgroundMusic.addEventListener('error', (e) => {
                console.error("Errore caricamento musica di sottofondo:", e);
                if (loadingIndicator) {
                    loadingIndicator.textContent = "Errore caricamento musica";
                    setTimeout(() => {
                        loadingIndicator.classList.add('hidden');
                    }, 3000);
                }
            });
            
            // Gestione dell'aggiornamento dell'elemento audio
            if (this.backgroundMusic.networkState === 1) {
                // Già caricato
                this.backgroundMusicLoaded = true;
                if (loadingIndicator) loadingIndicator.classList.add('hidden');
                if (this.backgroundMusicActive) this.playBackgroundMusic();
            }
        },
        
        playBackgroundMusic() {
            if (!this.backgroundMusic || !this.backgroundMusicLoaded) return;
            
            const playPromise = this.backgroundMusic.play();
            
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("Errore riproduzione musica di sottofondo:", error);
                    // In molti browser è necessaria un'interazione utente prima di riprodurre l'audio
                });
            }
        },
        
        stopBackgroundMusic() {
            if (!this.backgroundMusic) return;
            this.backgroundMusic.pause();
        },
        
        toggleBackgroundMusic() {
            this.backgroundMusicActive = !this.backgroundMusicActive;
            
            if (this.backgroundMusicActive) {
                this.playBackgroundMusic();
            } else {
                this.stopBackgroundMusic();
            }
        },
        
        playHurryUp() {
            if (!this.hurryUpSound) {
                console.error("Elemento audio per il suono hurry-up non trovato");
                return;
            }
            
            try {
                // Resetta il suono se stava già suonando
                this.hurryUpSound.pause();
                this.hurryUpSound.currentTime = 0;
                
                // Riproduci il suono
                const playPromise = this.hurryUpSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn("Errore riproduzione suono hurry-up:", error);
                    });
                }
            } catch (e) {
                console.error("Errore riproduzione hurry-up:", e);
            }
        },
        
        stopHurryUp() {
            if (!this.hurryUpSound) return;
            
            try {
                this.hurryUpSound.pause();
                this.hurryUpSound.currentTime = 0;
            } catch (e) {
                console.error("Errore arresto hurry-up:", e);
            }
        },
        
        playExplode() {
            if (!this.explodeSound) {
                console.error("Elemento audio per il suono explode non trovato");
                return;
            }
            
            try {
                // Resetta il suono se stava già suonando
                this.explodeSound.pause();
                this.explodeSound.currentTime = 0;
                
                // Riproduci il suono
                const playPromise = this.explodeSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn("Errore riproduzione suono explode:", error);
                    });
                }
            } catch (e) {
                console.error("Errore riproduzione explode:", e);
            }
        },
        
        playSynthSound(type) {
            try {
                if (!this.audioContext) this.initialize();
                
                const soundData = this.sounds[type];
                if (!soundData) return;
                
                // Feedback visivo
                const indicator = document.getElementById('sound-indicator');
                if (indicator) {
                    indicator.textContent = `♪ ${type}`;
                    indicator.classList.add('active');
                    setTimeout(() => indicator.classList.remove('active'), 1000);
                }
                
                // Se abbiamo un suono custom, usa il generatore dedicato
                if (soundData.custom&&typeof soundData.generate === 'function') {
                    soundData.generate(this.audioContext, this.sfxGainNode);
                    return;
                }
                
                // Altrimenti usa il generatore standard
                let startTime = this.audioContext.currentTime;
                
                for (let i = 0; i < soundData.freqs.length; i++) {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = type === 'bombExplosion' ? 'sawtooth' : 'sine';
                    oscillator.frequency.value = soundData.freqs[i];
                    
                    gainNode.gain.setValueAtTime(0.001, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.3, startTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + soundData.durations[i]);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGainNode);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + soundData.durations[i]);
                    
                    startTime += soundData.durations[i];
                }
            } catch (e) {
                console.error(`Errore riproduzione suono sintetizzato ${type}:`, e);
            }
        },
        
        playSound(type) {
            // Assicurati che AudioContext sia pronto
            if (!this.audioContext) this.initialize();
            
            // Riproduci il suono sintetizzato
            this.playSynthSound(type);
        }
    };
    
    // Funzione di utilità per riprodurre i suoni
    function playSound(soundType) {
        AudioSystem.playSound(soundType);
    }
    // --- Fine Modifica ---
    
    // --- MODIFICA: Liste di sillabe e probabilità ---
    const SYLS_1_LETTER = ["A", "E", "I", "O", "U"]; // Aggiungiamo le vocali singole
    const SYLS_2_LETTERS = [ // ESPANDI QUESTA LISTA!
        "PA", "RA", "MA", "NO", "SO", "LA", "MO", "NE", "LI", "PE", "RE", "TI", "CA", "SA", "LO", "MI", "CI", "VA",
        "LE", "RI", "ME", "TE", "BO", "DO", "NA", "BI", "CO", "DA", "DI", "FA", "FE", "FI", "FO", "FU", "GA", "GE",
        "GI", "NI", "PI", "PO", "PU", "RO", "RU", "SE", "SI", "SU", "TA", 
        "TO", "VI", "VO", "DE", "BA", "CE" 
        // Aggiungi molte altre sillabe comuni da 2 lettere
    ]; 
    const SYLS_3_LETTERS = [ // ESPANDI QUESTA LISTA!
        "PER", "TOR", "MAN", "CAN", "STR", "PRE", "GRA", "CES", "COS", "DAL", "DEL", "FRA", 
        "GIA", "GLI", "NON", "PAR", "PIO", "PIU", "PRI", "PRO", "QUA", "QUE", "QUI", "SCA", "SCE",
        "SCI", "STA", "STE", "STI", "STO", "TRA", "TRE", "TRI", "TRO", "VER", "VOL", "ZIO", "CAR",
        "TER", "MEN", "SEN", "CON", "ENT", "INT", "CIO", "CIA"
        // Aggiungi sillabe da 3 lettere comuni e utili per formare parole
    ]; 
    const PROB_ONE_LETTER_SYL = 0.15; // 15% probabilità per vocali singole
    const PROB_THREE_LETTER_SYL = 0.20; // 20% probabilità per sillaba da 3 lettere
    // --- Fine Modifica ---

    const DICT = new Set();
    let dizionarioPronto = false;
    const gameElement = document.getElementById("game");
    for (let i = 0; i < ROWS * COLS; i++) { const d = document.createElement("div"); d.className = "cell"; gameElement.appendChild(d); }
    const $ = q => document.querySelectorAll("#game .cell")[q];
    const idx = (x, y) => (y * COLS + x);

    let board, cur, gameLoopTimer, vowelChoiceTimerId, score = 0, words = 0, pieces = 0, gameIsOver = false, isVowelChoiceActive = false, vowelChoiceCellInfo = null;
    let isAnimatingClear = false; 
    let pendingBoardUpdateAfterAnimation = false;
    let isNextPieceBomb = false; 
    let bombPower = 0;      
    let currentDropInterval = START_DROP; 
    let chainCount = 0;     // Definizione della variabile chainCount
    let currentChainMultiplier = 1.0;  // Definizione della variabile currentChainMultiplier
    let isHurryUpPlaying = false;  // Flag per monitorare se hurry-up è in riproduzione
    let timerInterval = null; // Intervallo per l'aggiornamento del timer visivo

    const ui = { 
        s: document.getElementById("score"), 
        w: document.getElementById("words"), 
        p: document.getElementById("pieces"), 
        vowelSelection: document.getElementById("vowel-selection"), 
        lastWordVal: document.getElementById("last-word-val"),
        vowelTimerContainer: document.getElementById("vowel-timer-container"),
        vowelTimer: document.getElementById("vowel-timer")
    };

    // --- MODIFICA: randSyl aggiornata per includere vocali singole ---
    function randSyl() {
        const rand = Math.random();
        
        // Prima verifica se generare una vocale singola
        if (rand < PROB_ONE_LETTER_SYL) {
            return SYLS_1_LETTER[Math.floor(Math.random() * SYLS_1_LETTER.length)];
        }
        // Quindi verifica se generare una sillaba da 3 lettere
        else if (rand < PROB_ONE_LETTER_SYL + PROB_THREE_LETTER_SYL) {
            if (SYLS_3_LETTERS.length > 0) {
                return SYLS_3_LETTERS[Math.floor(Math.random() * SYLS_3_LETTERS.length)];
            }
        }
        
        // Altrimenti genera una sillaba da 2 lettere
        if (SYLS_2_LETTERS.length > 0) {
            return SYLS_2_LETTERS[Math.floor(Math.random() * SYLS_2_LETTERS.length)];
        } else if (SYLS_3_LETTERS.length > 0) { 
            return SYLS_3_LETTERS[Math.floor(Math.random() * SYLS_3_LETTERS.length)];
        } else if (SYLS_1_LETTER.length > 0) {
            return SYLS_1_LETTER[Math.floor(Math.random() * SYLS_1_LETTER.length)];
        } else {
            console.error("ERRORE: Tutte le liste di sillabe sono vuote!");
            return "??"; 
        }
    }
    // --- Fine Modifica ---

    function newPiece() {
        if (isNextPieceBomb) {
            isNextPieceBomb = false; 
            pieces++; ui.p.textContent = pieces;
            return { x: COLS >> 1, y: -1, h: 1, txt: ["💣"], isBomb: true, power: bombPower };
        }
        const r = Math.random(), h_normal = r < .3 ? 1 : r < .75 ? 2 : 3; const txt = [];
        while(txt.length < h_normal) { const s = randSyl(); if (!txt.includes(s)) txt.push(s); } // Usa la nuova randSyl
        pieces++; ui.p.textContent = pieces;
        if (txt.length > 0) {
            const sylIndexToMakeJoker = txt.length - 1; 
            const originalSyl = txt[sylIndexToMakeJoker];
            // La condizione originalSyl.length > 1 è importante se le tue SYLS_2_LETTERS/SYLS_3_LETTERS
            // dovessero contenere sillabe di una sola lettera (cosa che attualmente non fanno)
            if (/[AEIOU]$/.test(originalSyl)&&originalSyl.length > 1&&Math.random() < VOWEL_CHOICE_PROBABILITY) { 
                txt[sylIndexToMakeJoker] = originalSyl.slice(0, -1) + "*";
            }
        }
        return { x: COLS >> 1, y: -h_normal, h: txt.length, txt, isBomb: false };
    }

    function canMove(p, dx, dy) {
        if (!p || isAnimatingClear) return false;
        for (let i = 0; i < p.h; i++) {
            const nx = p.x + dx, ny = p.y + i + dy;
            if (nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0&&board[ny][nx]&&board[ny][nx] !== 'CLEARING_PLACEHOLDER')) return false;
        }
        return true;
    }

    function lockCurrentPiece() { 
        if (!dizionarioPronto || isAnimatingClear) return;
        clearInterval(gameLoopTimer); 

        // Riproduci il suono quando un pezzo atterra
        playSound('drop');

        if (cur.isBomb) {
            let landingRow = cur.y + cur.h - 1; 
            for(let i = cur.h -1; i >= 0; i--){ 
                if(cur.y + i >= ROWS -1 || (cur.y + i + 1 < ROWS&&board[cur.y + i + 1]&&board[cur.y + i + 1][cur.x])) { // Aggiunto check cur.y + i + 1 < ROWS
                    landingRow = cur.y + i; break;
                }
            }
            if (landingRow >= ROWS) landingRow = ROWS -1; 
            
            // Riproduci il suono dell'esplosione della bomba
            playSound('bombExplosion');
            
            detonateBomb(landingRow, cur.power, cur.x); 
            cur = null;
            processBoardAfterLock(); 
            return; 
        }

        let needsVowelChoice = false; vowelChoiceCellInfo = null;
        for (let i = 0; i < cur.h; i++) {
            const r_lock = cur.y + i, c_lock = cur.x;
            if (r_lock < 0) { draw(); handleGameOver(); return; }
            board[r_lock][c_lock] = cur.txt[i];
        }
        for (let i = 0; i < cur.h; i++) {
            const r_check = cur.y + i, c_check = cur.x;
            if (r_check >= 0&&cur.txt[i].endsWith("*")) {
                needsVowelChoice = true;
                vowelChoiceCellInfo = { r: r_check, c: c_check, prefix: cur.txt[i].slice(0, -1) };
                break; 
            }
        }
        cur = null; 
        draw(); 
        if (needsVowelChoice) {
            // Invece di riprodurre il suono sintetizzato, riproduci il file hurry-up.mp3
            // Riproduci il suono hurry-up quando appare il menu di scelta vocale
            AudioSystem.playHurryUp();
            isHurryUpPlaying = true;
            
            isVowelChoiceActive = true; 
            ui.vowelSelection.style.display = "block"; 
            
            // Mostra e avvia il timer visivo
            startVowelTimer();
            
            document.addEventListener('keydown', handleVowelKeyboardChoice);
            clearTimeout(vowelChoiceTimerId); 
            vowelChoiceTimerId = setTimeout(() => resolveVowelChoice(null), VOWEL_TIMEOUT);
        } else {
            processBoardAfterLock(); 
        }
    }
    
    // Funzione per avviare il timer visivo
    function startVowelTimer() {
        // Mostra il contenitore del timer
        ui.vowelTimerContainer.style.display = "block";
        // Imposta la larghezza del timer al 100%
        ui.vowelTimer.style.width = "100%";
        // Imposta la durata della transizione
        ui.vowelTimer.style.transition = `width ${VOWEL_TIMEOUT/1000}s linear`;
        
        // Forza un reflow per assicurarsi che la transizione funzioni
        void ui.vowelTimer.offsetWidth;
        
        // Avvia la transizione
        ui.vowelTimer.style.width = "0%";
    }
    
    // Funzione per fermare il timer visivo
    function stopVowelTimer() {
        ui.vowelTimerContainer.style.display = "none";
        ui.vowelTimer.style.transition = "none";
        ui.vowelTimer.style.width = "100%";
    }

    function detonateBomb(bombHitRow, numRowsToClear, bombCol) {
        if (numRowsToClear <= 0) return;
        let actualRowsCleared = 0;
        for (let i = 0; i < numRowsToClear; i++) {
            const rowToClear = bombHitRow - i; 
            if (rowToClear >= 0&&rowToClear < ROWS) {
                for (let c = 0; c < COLS; c++) board[rowToClear][c] = null; 
                actualRowsCleared++; score += 50 * (i + 1); 
            } else break; 
        }
    }

    function handleVowelKeyboardChoice(e) {
        if (!isVowelChoiceActive) return; const VOWELS = "AEIOU"; const keyPressed = e.key.toUpperCase();
        if (VOWELS.includes(keyPressed)) { e.preventDefault(); resolveVowelChoice(keyPressed); }
    }

    document.querySelectorAll('.vowel').forEach(el => el.addEventListener('click', e => { if (isVowelChoiceActive) resolveVowelChoice(e.target.getAttribute('data-vowel')); }));

    function resolveVowelChoice(chosenVowel) {
        if (!isVowelChoiceActive) return;
        clearTimeout(vowelChoiceTimerId); 
        document.removeEventListener('keydown', handleVowelKeyboardChoice);
        ui.vowelSelection.style.display = "none"; 
        isVowelChoiceActive = false;
        
        // Ferma il timer visivo
        stopVowelTimer();
        
        // Interrompi il suono hurry-up quando viene scelta una vocale o scade il tempo
        if (isHurryUpPlaying) {
            AudioSystem.stopHurryUp();
            isHurryUpPlaying = false;
        }
        
        // Se non è stata scelta una vocale (timeout scaduto), disintegra il tetramino
        if (!chosenVowel&&vowelChoiceCellInfo) {
            // Riproduci il suono di esplosione per la disintegrazione
            AudioSystem.playExplode();
            
            const { r, c } = vowelChoiceCellInfo;
            
            // Animazione di disintegrazione per la cella con il jolly
            if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c]&&board[r][c].endsWith("*")) {
                isAnimatingClear = true;
                
                const cellElement = $(idx(c, r));
                if (cellElement) {
                    cellElement.classList.add('clearing');
                    board[r][c] = 'CLEARING_PLACEHOLDER';
                    
                    // Mostra un messaggio nel lastWordVal
                    ui.lastWordVal.innerHTML = `<span style="color:#f55">JOLLY DISINTEGRATO!</span>`;
                    
                    setTimeout(() => {
                        if (board[r]&&board[r][c] === 'CLEARING_PLACEHOLDER') board[r][c] = null;
                        if (cellElement) {
                            cellElement.classList.remove('clearing');
                            cellElement.textContent = "";
                            cellElement.className = "cell";
                        }
                        isAnimatingClear = false;
                        processBoardAfterLock();
                    }, ANIMATION_CLEAR_DURATION);
                }
            } else {
                processBoardAfterLock();
            }
        } else if (chosenVowel&&vowelChoiceCellInfo) {
            // Se è stata scelta una vocale, sostituisci il jolly con la vocale
            const { r, c, prefix } = vowelChoiceCellInfo;
            if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c] === prefix + "*") {
                board[r][c] = prefix + chosenVowel;
            }
            vowelChoiceCellInfo = null; 
            draw();
            processBoardAfterLock();
        } else {
            vowelChoiceCellInfo = null; 
            draw();
            processBoardAfterLock();
        }
    }

    function processBoardAfterLock() {
        if (!dizionarioPronto || gameIsOver) return; 
        if (isAnimatingClear) return; 
        
        pendingBoardUpdateAfterAnimation = false;
        let iterations = 0; const MAX_ITERATIONS = ROWS * COLS; 
        let stabilityReached = false;
        let wordFoundThisOverallPBALCycle = false;

        while (iterations < MAX_ITERATIONS&&!stabilityReached&&!gameIsOver&&!isAnimatingClear) {
            iterations++;
            if (gameIsOver) break;
            collapse(); draw();
            if (isAnimatingClear) break; 

            let wordFoundThisScanPass = false; 
            if (scanAndClearHorizontalWords()) { wordFoundThisScanPass = true; wordFoundThisOverallPBALCycle = true; }
            if (isAnimatingClear || gameIsOver) break;

            if (scanAndClearVerticalWords()) { wordFoundThisScanPass = true; wordFoundThisOverallPBALCycle = true; }
            if (isAnimatingClear || gameIsOver) break;

            if (!wordFoundThisScanPass) stabilityReached = true; 
        } 
        
        if (!isAnimatingClear&&!gameIsOver) {
            ui.s.textContent = score; ui.w.textContent = words;
            cur = newPiece(); 
            
            if (cur.isBomb) { 
                currentDropInterval = Math.floor(START_DROP / 3);
            } else { 
                currentDropInterval = START_DROP;
            }
            // console.log("PBAL new piece. Drop interval:", currentDropInterval);

            if (!canMove(cur, 0, 0)) { draw(); handleGameOver(); return; }
            draw();
            if (!gameIsOver) {
                clearInterval(gameLoopTimer); 
                gameLoopTimer = setInterval(gameStep, currentDropInterval); 
            }
        }
    }

    function scanAndClearHorizontalWords() {
        if (gameIsOver || isAnimatingClear) return false; let clearedAny = false;
        for (let r = 0; r < ROWS; r++) {
            let currentRun = [];
            for (let c = 0; c < COLS; c++) {
                const cellContent = board[r][c];
                if (cellContent&&!cellContent.endsWith("*")&&cellContent !== 'CLEARING_PLACEHOLDER') currentRun.push({syl: cellContent, c: c });
                else { if (currentRun.length >= 2&&processRunForWords(currentRun, r, true)) clearedAny = true; currentRun = []; }
                if (isAnimatingClear) break; 
            }
            if (isAnimatingClear) break;
            if (currentRun.length >= 2&&processRunForWords(currentRun, r, true)) clearedAny = true;
        }
        return clearedAny;
    }

    function scanAndClearVerticalWords() {
        if (gameIsOver || isAnimatingClear) return false; let clearedAny = false;
        for (let c = 0; c < COLS; c++) {
            let currentRun = [];
            for (let r = 0; r < ROWS; r++) {
                const cellContent = board[r][c];
                if (cellContent&&!cellContent.endsWith("*")&&cellContent !== 'CLEARING_PLACEHOLDER') currentRun.push({syl: cellContent, r: r });
                else { if (currentRun.length >= 2&&processRunForWords(currentRun, c, false)) clearedAny = true; currentRun = []; }
                if (isAnimatingClear) break;
            }
            if (isAnimatingClear) break;
            if (currentRun.length >= 2&&processRunForWords(currentRun, c, false)) clearedAny = true;
        }
        return clearedAny;
    }

    function processRunForWords(run, fixedCoord, isHorizontal) {
        if (gameIsOver || isAnimatingClear) return false;
        for (let len = run.length; len >= 2; len--) {
            for (let i = 0; i <= run.length - len; i++) {
                const subRun = run.slice(i, i + len); const wordAttempt = subRun.map(item => item.syl).join("");
                if (DICT.has(wordAttempt)) {
                    let cellsAreValid = true;
                    for(const item of subRun) { const r_val = isHorizontal ? fixedCoord : item.r; const c_val = isHorizontal ? item.c : fixedCoord; if(!board[r_val] || board[r_val][c_val] !== item.syl || board[r_val][c_val] === 'CLEARING_PLACEHOLDER') { cellsAreValid = false; break; }}
                    if(cellsAreValid) {
                        // Riproduci il suono quando viene formata una parola valida
                        playSound('word');
                        
                        isAnimatingClear = true; clearInterval(gameLoopTimer);
                        const cellsToAnimate = [];
                        for (const item of subRun) { const r_anim = isHorizontal ? fixedCoord : item.r; const c_anim = isHorizontal ? item.c : fixedCoord; const cellElement = $(idx(c_anim, r_anim)); if (cellElement) { cellElement.classList.add('clearing'); cellsToAnimate.push({ r:r_anim, c:c_anim }); board[r_anim][c_anim] = 'CLEARING_PLACEHOLDER'; }}
                        
                        const numberOfSyllablesInGrid = subRun.length;
                        let bombaAttivataQuestoTurno = false;
                        if (numberOfSyllablesInGrid >= 3&&!isNextPieceBomb) { 
                            isNextPieceBomb = true;
                            bombPower = numberOfSyllablesInGrid - 2;
                            bombaAttivataQuestoTurno = true;
                        }
                        score += wordAttempt.length * 10; words++;
                        if (bombaAttivataQuestoTurno) {
                            ui.lastWordVal.innerHTML = wordAttempt + `<br><span style="color:orange;font-weight:bold;">BOMBA PRONTA! (${bombPower} righe)</span>`;
                        } else {
                            ui.lastWordVal.textContent = wordAttempt;
                        }
                        
                        setTimeout(() => {
                            cellsToAnimate.forEach(cellCoords => { if (board[cellCoords.r]&&board[cellCoords.r][cellCoords.c] === 'CLEARING_PLACEHOLDER') board[cellCoords.r][cellCoords.c] = null; const el = $(idx(cellCoords.c, cellCoords.r)); if (el) { el.classList.remove('clearing'); el.textContent = ""; el.className = "cell"; }});
                            isAnimatingClear = false; pendingBoardUpdateAfterAnimation = true;
                            if (!gameIsOver) processBoardAfterLock(); else draw(); 
                        }, ANIMATION_CLEAR_DURATION);
                        return true; 
                    }
                }
            }
        }
        return false;
    }

    function collapse() {
        if (gameIsOver || isAnimatingClear) return;
        for (let c = 0; c < COLS; c++) {
            let emptyRow = ROWS - 1;
            for (let r = ROWS - 1; r >= 0; r--) {
                const cellContent = board[r][c];
                if (cellContent&&cellContent !== 'CLEARING_PLACEHOLDER') {
                    if (r !== emptyRow) { board[emptyRow][c] = board[r][c]; board[r][c] = null; }
                    emptyRow--;
                }
            }
        }
    }

    function draw() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cellElement = $(idx(c, r));
                if (cellElement) {
                    const s_board = board[r][c];
                    if (s_board === 'CLEARING_PLACEHOLDER') { if(!cellElement.classList.contains('clearing')) {} continue; }
                    cellElement.textContent = s_board || "";
                    if (s_board) {
                        if (s_board === "💣") { 
                            cellElement.className = "cell bomb-cell";
                        } else {
                            cellElement.className = s_board.endsWith("*") ? "cell joker-cell" : "cell filled";
                        }
                    } else {
                        cellElement.className = "cell";
                    }
                }
            }
        }
        if (cur&&!gameIsOver&&!isAnimatingClear) {
            cur.txt.forEach((s_cur, i) => {
                const r_cur = cur.y + i;
                if (r_cur >= 0&&r_cur < ROWS) {
                    const cellElement = $(idx(cur.x, r_cur));
                    if (cellElement) { 
                        if (board[r_cur]&&board[r_cur][cur.x] === 'CLEARING_PLACEHOLDER') return;
                        cellElement.textContent = s_cur; 
                        if (cur.isBomb) { 
                            cellElement.className = "cell bomb-cell";
                        } else { 
                            cellElement.className = s_cur.endsWith("*") ? "cell joker-cell" : "cell filled";
                        }
                    }
                }
            });
        }
    }

    function gameStep() {
        if (isVowelChoiceActive || gameIsOver || !cur || !dizionarioPronto || isAnimatingClear) return;
        if (canMove(cur, 0, 1)) cur.y++; else lockCurrentPiece(); 
        if (cur&&!gameIsOver&&!isAnimatingClear) draw();
    }

    // Funzione per gestire le mosse (usata sia dai controlli touch che dalla tastiera)
    function handleMove(direction) {
        if (isVowelChoiceActive || gameIsOver || !cur || !dizionarioPronto || isAnimatingClear) return;
        
        let moved = false;
        const currentPieceCells = [];
        
        if (cur.isBomb) { 
            if (direction === 'left'&&canMove(cur, -1, 0)) { cur.x--; moved = true; }
            else if (direction === 'right'&&canMove(cur, 1, 0)) { cur.x++; moved = true; }
            else if (direction === 'down'&&canMove(cur, 0, 1)) { cur.y++; moved = true; }
        } else { 
            if (direction === 'left'&&canMove(cur, -1, 0)) { cur.x--; moved = true; }
            else if (direction === 'right'&&canMove(cur, 1, 0)) { cur.x++; moved = true; }
            else if (direction === 'down'&&canMove(cur, 0, 1)) { cur.y++; moved = true; } 
            else if (direction === 'rotate'&&cur.txt.length > 1) { cur.txt.unshift(cur.txt.pop()); moved = true; }
        }

        if(moved&&!gameIsOver&&!isAnimatingClear) {
            cur.txt.forEach((s_cur, i) => { 
                const r_cur = cur.y + i; 
                if (r_cur >= 0&&r_cur < ROWS) { 
                    const cellElement = $(idx(cur.x, r_cur)); 
                    if (cellElement&&(!board[r_cur] || board[r_cur][cur.x] !== 'CLEARING_PLACEHOLDER')) 
                        currentPieceCells.push(cellElement); 
                }
            });
            
            currentPieceCells.forEach(el => el.classList.add('piece-moved-feedback'));
            draw();
            setTimeout(() => currentPieceCells.forEach(el => el.classList.remove('piece-moved-feedback')), 100);
        }
    }

    // NUOVA SEZIONE: Gestione eventi touch
    function setupTouchControls() {
        // Previeni il bounce della pagina su touch devices
        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('#touch-controls')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Collega i bottoni touch alle azioni
        document.getElementById('touch-left').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('left');
            
            // Per ripetizione rapida (tenere premuto)
            startRepeatMove('left');
        });
        
        document.getElementById('touch-right').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('right');
            
            // Per ripetizione rapida (tenere premuto)
            startRepeatMove('right');
        });
        
        document.getElementById('touch-down').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('down');
            
            // Per ripetizione rapida (tenere premuto)
            startRepeatMove('down');
        });
        
        document.getElementById('touch-rotate').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('rotate');
        });
        
        // Interrompi la ripetizione quando si rilascia il touch
        const touchButtons = document.querySelectorAll('.touch-button');
        touchButtons.forEach(button => {
            button.addEventListener('touchend', stopRepeatMove);
            button.addEventListener('touchcancel', stopRepeatMove);
        });
    }
    
    let repeatMoveTimer = null;
    
    function startRepeatMove(direction) {
        // Prima fermati se è già in esecuzione
        stopRepeatMove();
        
        // Inizia un nuovo timer per ripetere la mossa
        repeatMoveTimer = setInterval(() => {
            handleMove(direction);
        }, 150); // ripeti ogni 150ms
    }
    
    function stopRepeatMove() {
        if (repeatMoveTimer) {
            clearInterval(repeatMoveTimer);
            repeatMoveTimer = null;
        }
    }

    // MODIFICA: Rimuovi il focus prima di gestire i tasti freccia
    document.addEventListener("keydown", e => {
        // Verifica se è attivo uno degli elementi di controllo volume e rimuovi focus
        const activeElement = document.activeElement;
        if (activeElement&&(activeElement.id === 'music-volume' || activeElement.id === 'sfx-volume')) {
            // Rimuovi il focus solo se è un tasto che usiamo nel gioco
            if (e.code === "ArrowLeft" || e.code === "ArrowRight" || 
                e.code === "ArrowUp" || e.code === "ArrowDown") {
                activeElement.blur();
            }
        }
        
        // Gestisci le mosse con la tastiera
        if (e.code === "ArrowLeft") handleMove('left');
        else if (e.code === "ArrowRight") handleMove('right');
        else if (e.code === "ArrowDown") handleMove('down');
        else if (e.code === "ArrowUp") handleMove('rotate');
    });

    function initializeActualGame() {
        if (!dizionarioPronto) { console.error("InitializeActualGame: Dizionario non pronto."); return; }
        gameIsOver = false; isVowelChoiceActive = false; isAnimatingClear = false; pendingBoardUpdateAfterAnimation = false;
        isNextPieceBomb = false; bombPower = 0; 
        chainCount = 0; currentChainMultiplier = 1.0; 
        isHurryUpPlaying = false;

        // Nascondi e resetta il timer
        stopVowelTimer();

        clearTimeout(vowelChoiceTimerId); if (document.activeElement&&typeof document.activeElement.blur === 'function') document.activeElement.blur();
        document.removeEventListener('keydown', handleVowelKeyboardChoice); ui.vowelSelection.style.display = "none";
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        score = 0; words = 0; pieces = 0; ui.s.textContent = 0; ui.w.textContent = 0; ui.p.textContent = 0; ui.lastWordVal.textContent = "---";
        
        cur = newPiece(); 
        if (cur.isBomb) { 
            currentDropInterval = Math.floor(START_DROP / 3);
        } else { 
            currentDropInterval = START_DROP;
        }
        
        draw();
        clearInterval(gameLoopTimer);
        if (!isAnimatingClear&&!gameIsOver) { gameLoopTimer = setInterval(gameStep, currentDropInterval); }
        
        // Assicurati che l'audio sia inizializzato
        AudioSystem.initialize();
        
        // Inizializza i controlli touch
        setupTouchControls();
    }

    function handleGameOver() {
        if (gameIsOver) return; gameIsOver = true; 
        clearInterval(gameLoopTimer); clearTimeout(vowelChoiceTimerId);
        
        // Nascondi e resetta il timer
        stopVowelTimer();
        
        // Interrompi il suono hurry-up se è in riproduzione
        if (isHurryUpPlaying) {
            AudioSystem.stopHurryUp();
            isHurryUpPlaying = false;
        }
        
        if (isVowelChoiceActive) { document.removeEventListener('keydown', handleVowelKeyboardChoice); ui.vowelSelection.style.display = "none"; isVowelChoiceActive = false; }
        draw(); 
        setTimeout(() => { alert(`GAME OVER\nPunti ${score}\nParole ${words}\nPezzi ${pieces}`); loadDictionaryAndInitGame(); }, 100 + (isAnimatingClear ? ANIMATION_CLEAR_DURATION : 0) );
    }

    async function loadDictionaryAndInitGame() {
        gameIsOver = false; isAnimatingClear = false; pendingBoardUpdateAfterAnimation = false; clearInterval(gameLoopTimer);
        DICT.clear(); dizionarioPronto = false; 
        ui.lastWordVal.textContent = "CARICAMENTO...";
        try {
            const response = await fetch('data/dizionario.txt'); // Assicurati che questo path sia corretto
            if (!response.ok) throw new Error(`Errore HTTP! Status: ${response.status} (${response.statusText}) per data/dizionario.txt`);
            const text = await response.text(); const paroleCaricate = text.trim().split(/\r?\n/);
            paroleCaricate.forEach(word => { const parolaPulita = word.trim().toUpperCase(); if (parolaPulita.length > 0) DICT.add(parolaPulita); });
            if (DICT.size === 0&&paroleCaricate.length > 0) console.warn("Dizionario caricato ma DICT è vuoto.");
            else if (DICT.size === 0) console.warn("Nessuna parola caricata nel dizionario.");
            dizionarioPronto = true; ui.lastWordVal.textContent = "---"; initializeActualGame();
        } catch (error) { console.error("Impossibile caricare il dizionario:", error); alert("Errore caricamento dizionario: " + error.message + "\nControlla console."); ui.lastWordVal.textContent = "ERRORE DIZIONARIO"; }
    }
    
    // Gestione overlay di avvio audio
    document.getElementById('start-game-button').addEventListener('click', function() {
        document.getElementById('audio-start-overlay').style.display = 'none';
        
        // Inizializza sistema audio con musica attiva
        AudioSystem.backgroundMusicActive = true;
        AudioSystem.initialize();
        
        // Avvia il gioco
        loadDictionaryAndInitGame();
    });
    
    // Il gioco inizia solo dopo che l'utente ha cliccato sul pulsante "Inizia"
</script>
</body>
</html>