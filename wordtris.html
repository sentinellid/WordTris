<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WordTris</title>
    <style>
        body { background: #111; color: #eee; font-family: sans-serif; text-align: center; margin: 0; padding-bottom: 80px; }
        
        /* Layout principale a due colonne */
        .game-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            margin: 0 auto;
            max-width: 95%;
            gap: 15px;
        }
        
        /* Colonna principale con la griglia */
        .main-column {
            flex: 1;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* Colonna laterale per statistiche */
        .stats-column {
            width: 120px;
            background: rgba(40, 40, 40, 0.5);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .stat-item {
            text-align: left;
            padding: 8px;
            background: rgba(60, 60, 60, 0.5);
            border-radius: 5px;
            font-size: 14px;
        }
        
        .stat-item .label {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 5px;
            display: block;
        }
        
        .stat-item .val {
            font-weight: bold;
            color: #7f7;
            font-size: 18px;
        }
        
        /* GRIGLIA AUMENTATA DEL 20% */
        #game { 
            margin: 10px auto 5px; 
            display: inline-grid; 
            grid-template-columns: repeat(10, 38px); /* Aumentato da 32px a 38px */
            grid-auto-rows: 38px; /* Aumentato da 32px a 38px */
            gap: 2px; 
            background: #2a2a2a; 
            padding: 2px; 
            border: 3px solid #555; 
            border-radius: 8px; 
        }
        
        .cell { 
            background: #383838; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font: 600 18px monospace; /* Aumentato da 15px a 18px */
            overflow: hidden; 
            user-select: none; 
            border-radius: 5px; 
            box-shadow: inset 0 0 4px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.3); 
            transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out; 
        }
        
        .filled { background: linear-gradient(145deg, #3ab0c0, #2f8a9a); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.2), inset 0 -1px 1px rgba(0,0,0,0.1), 0 2px 3px rgba(0,0,0,0.4); }
        .joker-cell { background: linear-gradient(145deg, #e04040, #b30000); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 2px 3px rgba(0,0,0,0.5), 0 0 6px rgba(255, 80, 80, 0.6); }
        .consonant-joker-cell { background: linear-gradient(145deg, #9040e0, #6000b3); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 2px 3px rgba(0,0,0,0.5), 0 0 6px rgba(160, 80, 255, 0.6); }
        .bomb-cell { background: linear-gradient(145deg, #555, #222); color: #ffcc00; font-size: 24px; border: 2px outset #777; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 3px 5px rgba(0,0,0,0.6), 0 0 10px rgba(255, 165, 0, 0.7); }
        .cell.clearing { animation: cellClearAnimation 0.5s forwards; position: relative; z-index: 100; }
        @keyframes cellClearAnimation { 0% { transform: scale(1.0); opacity: 1; background-color: #ffdd40; box-shadow: 0 0 15px #ffdd40; } 50% { transform: scale(1.2); opacity: 0.8; } 100% { transform: scale(0.3); opacity: 0; background-color: transparent; box-shadow: none; } }
        .piece-moved-feedback { outline: 1px solid rgba(255, 255, 0, 0.7); transition: outline 0.05s linear; }
        
        #last-word-display { 
            margin-top: 10px; 
            font-size: 15px; 
            color: #ccc; 
            min-height: 2.2em; 
            line-height: 1.2em; 
            padding: 5px 10px;
            background: rgba(40, 40, 40, 0.5);
            border-radius: 6px;
            width: 90%;
        }
        #last-word-display .val { color: #fa0; }
        
        /* NUOVO STILE: POPUP MODALE PER SELEZIONE */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 1000;
            backdrop-filter: blur(3px);
            animation: fadeIn 0.2s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 350px;
            background: #222;
            border-radius: 15px;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 255, 0.1);
            padding: 20px;
            text-align: center;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { transform: translate(-50%, -45%); opacity: 0.5; }
            to { transform: translate(-50%, -50%); opacity: 1; }
        }
        
        .modal-header {
            font-size: 18px;
            margin-bottom: 15px;
            color: #eee;
            font-weight: bold;
        }
        
        .modal-timer {
            height: 5px;
            width: 100%;
            background: #333;
            border-radius: 3px;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .timer-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #2a8, #fa0 40%, #f50 70%, #f00);
            border-radius: 3px;
            transition: width linear;
        }
        
        .selection-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        
        .selection-button {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: rgba(80, 80, 80, 0.8);
            color: white;
            transition: all 0.1s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .vowel-button {
            background: linear-gradient(145deg, #e04040, #b30000);
        }
        
        .consonant-button {
            background: linear-gradient(145deg, #9040e0, #6000b3);
        }
        
        .selection-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        
        .selection-button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        }
        
        /* Controllo audio semplificato */
        #audio-controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
        }
        #toggle-music {
            background: rgba(40, 40, 40, 0.8);
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #toggle-music.active {
            background: rgba(42, 136, 110, 0.8);
        }
        #toggle-music:hover {
            background: rgba(60, 60, 60, 0.9);
        }
        #toggle-music.active:hover {
            background: rgba(52, 166, 140, 0.9);
        }
        
        /* Indicatore di feedback audio */
        #sound-indicator { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 5px 10px; border-radius: 5px; font-size: 12px; opacity: 0; transition: opacity 0.2s ease; }
        #sound-indicator.active { opacity: 1; }
        
        /* Stato di caricamento audio */
        #audio-loading {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #ff6;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        #audio-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Stile per l'overlay di avvio */
        #audio-start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        #audio-start-overlay h2 {
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(255,255,255,0.2);
        }
        #audio-start-overlay p {
            font-size: 16px;
            max-width: 500px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.4;
            padding: 0 15px;
        }
        
        #audio-start-overlay .start-logo {
            max-width: 250px;
            height: auto;
            margin-bottom: 15px;
        }
        
        #start-game-button {
            padding: 12px 24px;
            margin: 15px 0;
            font-size: 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            font-weight: bold;
            background: linear-gradient(145deg, #3ab0c0, #2a8);
            color: white;
        }
        
        #start-game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #start-game-button:active {
            transform: translateY(0);
        }

        /* Controlli touch ottimizzati */
        #touch-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 5px 0;
            background: rgba(20, 20, 20, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            box-shadow: 0 -3px 10px rgba(0,0,0,0.4);
        }

        .touch-button {
            width: 60px;
            height: 60px;
            background: rgba(60, 60, 60, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            transition: all 0.1s ease;
        }

        .touch-button:active {
            background: rgba(100, 100, 100, 0.9);
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }

        /* Pulsante pausa */
        #pause-button {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(60, 60, 60, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white;
            font-size: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 990;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        #pause-button:hover {
            background: rgba(80, 80, 80, 0.9);
        }

        /* Overlay di pausa */
        #pause-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1500;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            backdrop-filter: blur(3px);
        }

        #pause-overlay h2 {
            font-size: 32px;
            margin-bottom: 30px;
            color: white;
        }

        #resume-button {
            padding: 12px 30px;
            background: linear-gradient(145deg, #3ab0c0, #2a8);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        #resume-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        }

        #restart-button {
            padding: 10px 25px;
            background: rgba(80, 80, 80, 0.7);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        #restart-button:hover {
            background: rgba(100, 100, 100, 0.8);
        }

        /* NUOVO: Overlay di livello completato */
        #level-complete-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1600;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            backdrop-filter: blur(3px);
            text-align: center;
        }

        #level-complete-overlay h2 {
            font-size: 32px;
            margin-bottom: 10px;
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 0, 0.8);
        }

        #level-complete-overlay .level-stats {
            color: #ddd;
            font-size: 18px;
            margin: 20px 0;
            line-height: 1.4;
        }

        #level-complete-overlay .level-stats .stat-value {
            color: #7f7;
            font-weight: bold;
        }

        #next-level-button {
            padding: 12px 30px;
            background: linear-gradient(145deg, #ffb347, #ffcc33);
            color: #333;
            border: none;
            border-radius: 6px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        #next-level-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 200, 0, 0.5);
        }

        /* NUOVO: Indicatore di livello */
        #level-indicator {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(50, 50, 50, 0.8);
            color: #ffcc33;
            padding: 4px 12px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 100;
        }

        /* Progresso obiettivo livello */
        #level-progress-container {
            width: 90%;
            height: 8px;
            background: rgba(40, 40, 40, 0.6);
            border-radius: 4px;
            margin: 5px 0 10px;
            overflow: hidden;
        }

        #level-progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ffcc33, #ff9933);
            border-radius: 4px;
            transition: width 0.3s ease-out;
        }

        /* Media queries per dispositivi mobili */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column-reverse;
                align-items: center;
            }
            
            .stats-column {
                width: 90%;
                flex-direction: row;
                justify-content: space-around;
                padding: 8px;
                margin-top: 0;
                margin-bottom: 10px;
            }
            
            .stat-item {
                flex: 1;
                text-align: center;
                padding: 5px;
                max-width: 80px;
            }
            
            #game {
                grid-template-columns: repeat(10, 34px); /* Aumentato da 28px a 34px */
                grid-auto-rows: 34px; /* Aumentato da 28px a 34px */
                gap: 1px;
                margin-top: 5px;
            }
            
            .cell {
                font-size: 14px; /* Aumentato da 12px a 14px */
            }
            
            .touch-button {
                width: 52px;
                height: 52px;
                font-size: 20px;
            }
            
            #last-word-display {
                font-size: 14px;
                min-height: 2em;
            }
            
            .selection-button {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }
            
            #pause-button {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding-bottom: 70px;
            }
            
            .game-container {
                gap: 5px;
            }
            
            .stats-column {
                padding: 5px;
                gap: 5px;
            }
            
            .stat-item {
                padding: 3px;
                max-width: 70px;
            }
            
            .stat-item .val {
                font-size: 16px;
            }
            
            #game {
                grid-template-columns: repeat(10, 29px); /* Aumentato da 24px a 29px */
                grid-auto-rows: 29px; /* Aumentato da 24px a 29px */
                margin-top: 3px;
            }
            
            .cell {
                font-size: 12px; /* Aumentato da 10px a 12px */
            }
            
            .touch-button {
                width: 48px;
                height: 48px;
                font-size: 18px;
            }
            
            #touch-controls {
                padding: 3px 0;
            }
            
            #toggle-music {
                font-size: 12px;
                padding: 6px 10px;
            }
            
            .selection-button {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .modal-container {
                padding: 15px;
            }
            
            .modal-header {
                font-size: 16px;
                margin-bottom: 10px;
            }
            
            #pause-button {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }
        
        /* Ulteriori ottimizzazioni per schermi molto piccoli */
        @media (max-width: 360px) {
            #game {
                grid-template-columns: repeat(10, 26px); /* Aumentato da 22px a 26px */
                grid-auto-rows: 26px; /* Aumentato da 22px a 26px */
            }
            
            .cell {
                font-size: 11px; /* Aumentato da 10px a 11px */
            }
            
            .touch-button {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            #last-word-display {
                font-size: 12px;
            }
            
            .selection-button {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
            
            #pause-button {
                width: 30px;
                height: 30px;
                font-size: 12px;
            }
        }

        /* Nasconde i controlli touch quando è disponibile un mouse */
        @media (hover: hover) and (pointer: fine) {
            #touch-controls {
                display: none;
            }
            
            body {
                padding-bottom: 20px;
            }
        }

        /* Ottimizzazioni specifiche per dispositivi con schermi molto piccoli */
        @media screen and (max-width: 360px) and (max-height: 640px) {
            #game {
                grid-template-columns: repeat(10, 24px);
                grid-auto-rows: 24px;
                gap: 1px;
            }
            
            .stats-column {
                padding: 3px;
                gap: 3px;
            }
            
            .stat-item {
                padding: 2px;
                max-width: 60px;
            }

            .stat-item .label {
                font-size: 10px;
                margin-bottom: 2px;
            }
            
            .stat-item .val {
                font-size: 14px;
            }
        }
        
        /* Media query ultra-specifica per iPhone 8 e dispositivi simili */
        @media screen and (max-width: 375px) and (max-height: 667px) and (-webkit-device-pixel-ratio: 2) {
            .stats-column {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 3px;
                padding: 4px;
            }
            
            .stat-item {
                font-size: 90%;
            }
        }
        
        /* Stili per dispositivi molto piccoli (sotto i 320px) */
        @media (max-width: 320px) {
            #game {
                grid-template-columns: repeat(10, 22px);
                grid-auto-rows: 22px;
            }
            
            .stats-column {
                flex-wrap: wrap;
            }
            
            .stat-item {
                flex-basis: 45%;
                max-width: none;
                margin-bottom: 3px;
            }

            #touch-controls {
                padding: 2px 0;
                gap: 8px;
            }
            
            .touch-button {
                width: 36px;
                height: 36px;
                font-size: 13px;
                border-radius: 8px;
            }
        }
        
        /* Ottimizzazione specifica per iPhone 12 e modelli simili */
        @media only screen 
        and (device-width: 390px) 
        and (device-height: 844px) 
        and (-webkit-device-pixel-ratio: 3),
        /* iPhone 12 Pro */
        only screen 
        and (device-width: 428px) 
        and (device-height: 926px) 
        and (-webkit-device-pixel-ratio: 3),
        /* iPhone 12 Pro Max */
        only screen 
        and (device-width: 375px) 
        and (device-height: 812px) 
        and (-webkit-device-pixel-ratio: 3),
        /* iPhone X/XS */
        only screen 
        and (device-width: 414px) 
        and (device-height: 896px) 
        and (-webkit-device-pixel-ratio: 2) {
            
            #game {
                grid-template-columns: repeat(10, 32px);
                grid-auto-rows: 32px;
                gap: 1px;
            }
            
            body {
                padding-bottom: 80px;
            }
            
            .stats-column {
                display: flex;
                flex-direction: row;
                justify-content: space-around;
                padding: 5px;
                gap: 5px;
                margin-bottom: 5px;
            }
            
            #touch-controls {
                padding: 3px 0;
            }
            
            .touch-button {
                width: 55px;
                height: 55px;
            }
        }

        /* Stili che si attivano SOLO quando JS ha rilevato un dispositivo problematico */
        .small-device-optimized .stat-item {
            padding: 2px;
            font-size: 90%;
        }

        .small-device-optimized .stat-item .label {
            font-size: 10px;
            margin-bottom: 2px;
        }

        .small-device-optimized .stat-item .val {
            font-size: 14px;
        }
        
        /* Stili specifici per Galaxy Watch e dispositivi molto piccoli simili */
        .galaxy-watch-optimized .stats-column {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            padding: 2px;
            gap: 2px;
        }

        .galaxy-watch-optimized .stat-item {
            flex: 0 0 auto;
            font-size: 80%;
            padding: 1px;
        }
        
        /* Stili per iPhone recenti */
        .iphone-optimized #game {
            margin-bottom: 10px;
        }
        
        .iphone-optimized .touch-button {
            width: 55px;
            height: 55px;
            font-size: 22px;
        }
        
        .iphone-optimized #touch-controls {
            padding: 5px 0;
        }
    </style>
</head>
<body>
    <!-- Overlay per l'avvio dell'audio -->
    <div id="audio-start-overlay">
        <img src="img/logo.png" alt="WordTris Logo" class="start-logo">
        <div>
            <button id="toggle-music" class="active">Musica: ON</button>
        </div>
        <h2>WordTris</h2>
        <p>Un gioco di parole ispirato a Tetris. Componi parole italiane usando le sillabe che cadono!</p>
        <button id="start-game-button">Inizia</button>
    </div>

    <!-- Pulsante pausa -->
    <div id="pause-button">⏸️</div>

    <!-- Overlay di pausa -->
    <div id="pause-overlay">
        <h2>Pausa</h2>
        <button id="resume-button">Riprendi</button>
        <button id="restart-button">Ricomincia</button>
    </div>
    
    <!-- NUOVO: Overlay livello completato -->
    <div id="level-complete-overlay">
        <h2>Livello Completato!</h2>
        <div class="level-stats">
            Livello <span id="current-level-complete" class="stat-value">1</span> completato<br>
            Punteggio: <span id="level-score" class="stat-value">0</span><br>
            Parole trovate: <span id="level-words" class="stat-value">0</span>
        </div>
        <div>
            <button id="next-level-button">Livello Successivo</button>
        </div>
    </div>

    <div class="game-container">
        <!-- Colonna delle statistiche -->
        <div class="stats-column">
            <div class="stat-item">
                <span class="label">Punti</span>
                <span id="score" class="val">0</span>
            </div>
            <div class="stat-item">
                <span class="label">Parole</span>
                <span id="words" class="val">0</span>
            </div>
            <div class="stat-item">
                <span class="label">Pezzi</span>
                <span id="pieces" class="val">0</span>
            </div>
            <!-- NUOVO: Livello -->
            <div class="stat-item">
                <span class="label">Livello</span>
                <span id="level" class="val">1</span>
            </div>
        </div>
        
        <!-- Colonna principale con il gioco -->
        <div class="main-column">
            <!-- NUOVO: Indicatore di livello e progresso -->
            <div id="level-indicator">Livello 1</div>
            <div id="level-progress-container">
                <div id="level-progress-bar"></div>
            </div>
            
            <div id="game"></div>
            <div id="last-word-display">Ultima Parola: <span id="last-word-val" class="val">---</span></div>
        </div>
    </div>
    
    <!-- NUOVO: Modal popup per la selezione di vocali -->
    <div id="vowel-modal" class="modal-overlay">
        <div class="modal-container">
            <div class="modal-header">Scegli una vocale (o premi A,E,I,O,U)</div>
            <div class="modal-timer">
                <div id="vowel-timer" class="timer-bar"></div>
            </div>
            <div class="selection-buttons">
                <button class="selection-button vowel-button" data-vowel="A">A</button>
                <button class="selection-button vowel-button" data-vowel="E">E</button>
                <button class="selection-button vowel-button" data-vowel="I">I</button>
                <button class="selection-button vowel-button" data-vowel="O">O</button>
                <button class="selection-button vowel-button" data-vowel="U">U</button>
            </div>
        </div>
    </div>
    
    <!-- NUOVO: Modal popup per la selezione di consonanti -->
    <div id="consonant-modal" class="modal-overlay">
        <div class="modal-container">
            <div class="modal-header">Scegli una consonante</div>
            <div class="modal-timer">
                <div id="consonant-timer" class="timer-bar"></div>
            </div>
            <div class="selection-buttons" id="consonant-buttons">
                <!-- I pulsanti delle consonanti verranno generati dinamicamente qui -->
            </div>
        </div>
    </div>
    
    <div id="sound-indicator">♪</div>
    <div id="audio-loading">Caricamento audio...</div>
    
    <!-- Controlli touch per dispositivi mobili -->
    <div id="touch-controls">
        <div class="touch-button" id="touch-left">⬅️</div>
        <div class="touch-button" id="touch-rotate">🔄</div>
        <div class="touch-button" id="touch-right">➡️</div>
        <div class="touch-button" id="touch-down">⬇️</div>
    </div>
    
    <!-- Audio background nascosto -->
    <audio id="background-music" loop preload="auto">
        <source src="audio/background_music.mp3" type="audio/mp3">
    </audio>
    
    <!-- Audio hurry-up per la scelta vocale -->
    <audio id="hurry-up-sound" preload="auto">
        <source src="audio/hurry-up.mp3" type="audio/mp3">
    </audio>
    
    <!-- Audio per l'esplosione del tetramino -->
    <audio id="explode-sound" preload="auto">
        <source src="audio/explode.mp3" type="audio/mp3">
    </audio>
    
    <!-- NUOVO: Audio per il livello completato -->
    <audio id="level-up-sound" preload="auto">
        <source src="audio/level-up.mp3" type="audio/mp3">
    </audio>
    
<script>
    // NUOVO: Configurazione dei livelli
    const LEVEL_CONFIG = [
        { 
            level: 1, 
            rows: 14,                   // Parte con 14 righe
            columns: 8,                 // E 8 colonne
            startDropInterval: 1000,    // Velocità di caduta iniziale
            scoreToComplete: 1000,      // Punti per completare
            syls1LetterProb: 0.15,      // Probabilità sillabe da 1 lettera (vocali)
            syls3LetterProb: 0.15,      // Probabilità sillabe da 3 lettere
            vowelJokerProb: 0.20,       // Probabilità jolly vocale
            consonantJokerProb: 0.10    // Probabilità jolly consonante
        },
        { 
            level: 2, 
            rows: 15, 
            columns: 9, 
            startDropInterval: 900, 
            scoreToComplete: 2000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.18,
            vowelJokerProb: 0.25,
            consonantJokerProb: 0.15
        },
        { 
            level: 3, 
            rows: 16, 
            columns: 9, 
            startDropInterval: 800, 
            scoreToComplete: 3000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.20,
            vowelJokerProb: 0.25,
            consonantJokerProb: 0.15
        },
        { 
            level: 4, 
            rows: 16, 
            columns: 10, 
            startDropInterval: 750, 
            scoreToComplete: 4000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.20,
            vowelJokerProb: 0.30,
            consonantJokerProb: 0.20
        },
        { 
            level: 5, 
            rows: 17, 
            columns: 10, 
            startDropInterval: 700, 
            scoreToComplete: 5000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.25,
            vowelJokerProb: 0.30,
            consonantJokerProb: 0.20
        },
        { 
            level: 6, 
            rows: 17, 
            columns: 10, 
            startDropInterval: 650, 
            scoreToComplete: 6000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.25,
            vowelJokerProb: 0.35,
            consonantJokerProb: 0.25
        },
        { 
            level: 7, 
            rows: 17, 
            columns: 10, 
            startDropInterval: 600, 
            scoreToComplete: 7000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.30,
            vowelJokerProb: 0.35,
            consonantJokerProb: 0.25
        },
        { 
            level: 8, 
            rows: 17, 
            columns: 10, 
            startDropInterval: 550, 
            scoreToComplete: 8000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.30,
            vowelJokerProb: 0.35,
            consonantJokerProb: 0.25
        },
        { 
            level: 9, 
            rows: 17, 
            columns: 10, 
            startDropInterval: 500, 
            scoreToComplete: 9000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.35,
            vowelJokerProb: 0.40,
            consonantJokerProb: 0.30
        },
        { 
            level: 10, 
            rows: 17, 
            columns: 10, 
            startDropInterval: 450, 
            scoreToComplete: 10000,
            syls1LetterProb: 0.15,
            syls3LetterProb: 0.35,
            vowelJokerProb: 0.40,
            consonantJokerProb: 0.30
        }
        // Puoi aggiungere più livelli se necessario
    ];

    // Variabili iniziali (saranno aggiornate in base al livello)
    let ROWS = LEVEL_CONFIG[0].rows;
    let COLS = LEVEL_CONFIG[0].columns;
    let START_DROP = LEVEL_CONFIG[0].startDropInterval;
    const VOWEL_TIMEOUT = 3000;
    const ANIMATION_CLEAR_DURATION = 500;
    
    // --- Sistema audio semplificato ---
    const AudioSystem = {
        audioContext: null,
        backgroundMusic: document.getElementById('background-music'),
        hurryUpSound: document.getElementById('hurry-up-sound'),
        explodeSound: document.getElementById('explode-sound'),
        levelUpSound: document.getElementById('level-up-sound'),
        sfxGainNode: null,
        backgroundMusicActive: true,
        backgroundMusicLoaded: false,
        
        // Impostazioni suoni
        sounds: {
            drop: { freqs: [220, 165], durations: [0.05, 0.1] },
            selectVowel: { freqs: [440, 660], durations: [0.1, 0.1] },
            selectConsonant: { freqs: [550, 330], durations: [0.1, 0.1] },
            word: { freqs: [440, 493, 523, 587], durations: [0.08, 0.08, 0.08, 0.2] },
            bombExplosion: { 
                custom: true, 
                generate: function(audioContext, gainNode) {
                    const duration = 1.2;
                    const now = audioContext.currentTime;
                    
                    // Suono 1: Boom basso
                    const boom = audioContext.createOscillator();
                    const boomGain = audioContext.createGain();
                    boom.type = 'sawtooth';
                    boom.frequency.setValueAtTime(120, now);
                    boom.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                    boomGain.gain.setValueAtTime(0.01, now);
                    boomGain.gain.exponentialRampToValueAtTime(0.7, now + 0.05);
                    boomGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    boom.connect(boomGain);
                    boomGain.connect(gainNode);
                    boom.start(now);
                    boom.stop(now + duration);
                    
                    // Suono 2: Rumore esplosione
                    const bufferSize = audioContext.sampleRate * 1.5;
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    // Generazione del rumore bianco
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    
                    // Suono "scoppio"
                    const noise = audioContext.createBufferSource();
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    
                    noise.buffer = noiseBuffer;
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.setValueAtTime(8000, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(800, now + 0.6);
                    noiseGain.gain.setValueAtTime(0.01, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.25, now + 0.05);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(gainNode);
                    
                    noise.start(now);
                    noise.stop(now + duration);
                    
                    // Suono 3: Riverbero post-esplosione
                    setTimeout(() => {
                        const reverb = audioContext.createOscillator();
                        const reverbGain = audioContext.createGain();
                        const reverbFilter = audioContext.createBiquadFilter();
                        
                        reverb.type = 'sine';
                        reverb.frequency.setValueAtTime(400, now + 0.1);
                        reverb.frequency.exponentialRampToValueAtTime(100, now + 1.0);
                        
                        reverbFilter.type = 'bandpass';
                        reverbFilter.frequency.value = 200;
                        reverbFilter.Q.value = 3;
                        
                        reverbGain.gain.setValueAtTime(0.05, now + 0.1);
                        reverbGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                        
                        reverb.connect(reverbFilter);
                        reverbFilter.connect(reverbGain);
                        reverbGain.connect(gainNode);
                        
                        reverb.start(now + 0.1);
                        reverb.stop(now + duration);
                    }, 100);
                }
            }
        },
        
        initialize() {
            try {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Crea il nodo di guadagno per effetti sonori
                    this.sfxGainNode = this.audioContext.createGain();
                    this.sfxGainNode.gain.value = 0.7; // Volume SFX al 70%
                    this.sfxGainNode.connect(this.audioContext.destination);
                    
                    // Gestione della musica di sottofondo
                    this.initBackgroundMusic();
                    
                    // Inizializza i controlli dell'interfaccia
                    this.setupUIControls();
                }
                console.log("Sistema audio inizializzato");
            } catch (e) {
                console.error("Errore inizializzazione audio:", e);
            }
        },
        
        setupUIControls() {
            // Toggle musica
            const musicToggle = document.getElementById('toggle-music');
            if (musicToggle) {
                musicToggle.addEventListener('click', () => {
                    this.toggleBackgroundMusic();
                    musicToggle.textContent = this.backgroundMusicActive ? 'Musica: ON' : 'Musica: OFF';
                    musicToggle.className = this.backgroundMusicActive ? 'active' : '';
                });
            }
        },
        
        initBackgroundMusic() {
            if (!this.backgroundMusic) {
                console.error("Elemento audio per la musica di sottofondo non trovato");
                return;
            }
            
            // Mostra indicatore di caricamento
            const loadingIndicator = document.getElementById('audio-loading');
            
            // Imposta il volume a un valore più basso (20%)
            this.backgroundMusic.volume = 0.2;
            
            // Gestisci eventi di caricamento audio
            this.backgroundMusic.addEventListener('canplaythrough', () => {
                console.log("Musica di sottofondo caricata");
                this.backgroundMusicLoaded = true;
                
                if (loadingIndicator) {
                    loadingIndicator.classList.add('hidden');
                }
                
                // Avvia la riproduzione se attivo
                if (this.backgroundMusicActive) {
                    this.playBackgroundMusic();
                }
            });
            
            this.backgroundMusic.addEventListener('error', (e) => {
                console.error("Errore caricamento musica di sottofondo:", e);
                if (loadingIndicator) {
                    loadingIndicator.textContent = "Errore caricamento musica";
                    setTimeout(() => {
                        loadingIndicator.classList.add('hidden');
                    }, 3000);
                }
            });
            
            // Gestione dell'aggiornamento dell'elemento audio
            if (this.backgroundMusic.networkState === 1) {
                // Già caricato
                this.backgroundMusicLoaded = true;
                if (loadingIndicator) loadingIndicator.classList.add('hidden');
                if (this.backgroundMusicActive) this.playBackgroundMusic();
            }
        },
        
        playBackgroundMusic() {
            if (!this.backgroundMusic || !this.backgroundMusicLoaded) return;
            
            const playPromise = this.backgroundMusic.play();
            
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("Errore riproduzione musica di sottofondo:", error);
                });
            }
        },
        
        stopBackgroundMusic() {
            if (!this.backgroundMusic) return;
            this.backgroundMusic.pause();
        },
        
        toggleBackgroundMusic() {
            this.backgroundMusicActive = !this.backgroundMusicActive;
            
            if (this.backgroundMusicActive) {
                this.playBackgroundMusic();
            } else {
                this.stopBackgroundMusic();
            }
        },
        
        playHurryUp() {
            if (!this.hurryUpSound) {
                console.error("Elemento audio per il suono hurry-up non trovato");
                return;
            }
            
            try {
                // Resetta il suono se stava già suonando
                this.hurryUpSound.pause();
                this.hurryUpSound.currentTime = 0;
                
                // Imposta volume al 70%
                this.hurryUpSound.volume = 0.7;
                
                // Riproduci il suono
                const playPromise = this.hurryUpSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn("Errore riproduzione suono hurry-up:", error);
                    });
                }
            } catch (e) {
                console.error("Errore riproduzione hurry-up:", e);
            }
        },
        
        stopHurryUp() {
            if (!this.hurryUpSound) return;
            
            try {
                this.hurryUpSound.pause();
                this.hurryUpSound.currentTime = 0;
            } catch (e) {
                console.error("Errore arresto hurry-up:", e);
            }
        },
        
        playExplode() {
            if (!this.explodeSound) {
                console.error("Elemento audio per il suono explode non trovato");
                return;
            }
            
            try {
                // Resetta il suono se stava già suonando
                this.explodeSound.pause();
                this.explodeSound.currentTime = 0;
                
                // Imposta volume al 70%
                this.explodeSound.volume = 0.7;
                
                // Riproduci il suono
                const playPromise = this.explodeSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn("Errore riproduzione suono explode:", error);
                    });
                }
            } catch (e) {
                console.error("Errore riproduzione explode:", e);
            }
        },
        
        playLevelUp() {
            if (!this.levelUpSound) {
                console.error("Elemento audio per il suono level-up non trovato");
                return;
            }
            
            try {
                // Resetta il suono se stava già suonando
                this.levelUpSound.pause();
                this.levelUpSound.currentTime = 0;
                
                // Imposta volume al 70%
                this.levelUpSound.volume = 0.7;
                
                // Riproduci il suono
                const playPromise = this.levelUpSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn("Errore riproduzione suono level-up:", error);
                    });
                }
            } catch (e) {
                console.error("Errore riproduzione level-up:", e);
            }
        },
        
        playSynthSound(type) {
            try {
                if (!this.audioContext) this.initialize();
                
                const soundData = this.sounds[type];
                if (!soundData) return;
                
                // Feedback visivo
                const indicator = document.getElementById('sound-indicator');
                if (indicator) {
                    indicator.textContent = `♪ ${type}`;
                    indicator.classList.add('active');
                    setTimeout(() => indicator.classList.remove('active'), 1000);
                }
                
                // Se abbiamo un suono custom, usa il generatore dedicato
                if (soundData.custom&&typeof soundData.generate === 'function') {
                    soundData.generate(this.audioContext, this.sfxGainNode);
                    return;
                }
                
                // Altrimenti usa il generatore standard
                let startTime = this.audioContext.currentTime;
                
                for (let i = 0; i < soundData.freqs.length; i++) {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = type === 'bombExplosion' ? 'sawtooth' : 'sine';
                    oscillator.frequency.value = soundData.freqs[i];
                    
                    gainNode.gain.setValueAtTime(0.001, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.3, startTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + soundData.durations[i]);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGainNode);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + soundData.durations[i]);
                    
                    startTime += soundData.durations[i];
                }
            } catch (e) {
                console.error(`Errore riproduzione suono sintetizzato ${type}:`, e);
            }
        },
        
        playSound(type) {
            // Assicurati che AudioContext sia pronto
            if (!this.audioContext) this.initialize();
            
            // Riproduci il suono sintetizzato
            this.playSynthSound(type);
        }
    };
    
    // Funzione di utilità per riprodurre i suoni
    function playSound(soundType) {
        AudioSystem.playSound(soundType);
    }
    
    // --- Dati di gioco ---
    const VOWELS = ["A", "E", "I", "O", "U"];
    const CONSONANTS = ["B", "C", "D", "F", "G", "H", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "Z"];
    const SYLS_1_LETTER = ["A", "E", "I", "O", "U"]; 
    const SYLS_2_LETTERS = [ 
        "PA", "RA", "MA", "NO", "SO", "LA", "MO", "NE", "LI", "PE", "RE", "TI", "CA", "SA", "LO", "MI", "CI", "VA",
        "LE", "RI", "ME", "TE", "BO", "DO", "NA", "BI", "CO", "DA", "DI", "FA", "FE", "FI", "FO", "FU", "GA", "GE",
        "GI", "NI", "PI", "PO", "SE", "SI", "SU", "TA", 
        "TO", "VI", "VO", "DE", "BA", "CE" 
    ]; 
    const SYLS_3_LETTERS = [ 
        "PER", "TOR", "MAN", "CAN", "STR", "PRE", "GRA", "CES", "COS", "DAL", "DEL", "FRA", 
        "GIA", "GLI", "NON", "PAR", "PIO", "PIU", "PRI", "PRO", "SCE",
        "SCI", "STA", "STE", "STI", "STO", "TRA", "TRE", "TRI", "TRO", "VER", "VOL", "ZIO", "CAR",
        "TER", "MEN", "SEN", "CON", "CIO", "CIA"
    ]; 
    
    // Queste variabili verranno impostate dal livello corrente
    let PROB_ONE_LETTER_SYL = LEVEL_CONFIG[0].syls1LetterProb; 
    let PROB_THREE_LETTER_SYL = LEVEL_CONFIG[0].syls3LetterProb;
    let VOWEL_CHOICE_PROBABILITY = LEVEL_CONFIG[0].vowelJokerProb;
    let CONSONANT_CHOICE_PROBABILITY = LEVEL_CONFIG[0].consonantJokerProb;
    
    // Numero di consonanti da mostrare alla volta per la selezione
    const NUM_CONSONANT_CHOICES = 5;

    const DICT = new Set();
    let dizionarioPronto = false;
    let gameElement = document.getElementById("game");
    
    // MODIFICATO: Funzione di utilità per selezionare celle dinamicamente
    let $ = function(q) { 
        return document.querySelectorAll("#game .cell")[q];
    };
    
    const idx = (x, y) => (y * COLS + x);

    let board, cur, gameLoopTimer, choiceTimerId, score = 0, words = 0, pieces = 0, gameIsOver = false, isChoiceActive = false;
    let isVowelChoice = false; // true per vocali, false per consonanti
    let choiceCellInfo = null;
    let isAnimatingClear = false; 
    let pendingBoardUpdateAfterAnimation = false;
    let isNextPieceBomb = false; 
    let bombPower = 0;      
    let currentDropInterval = START_DROP; 
    let chainCount = 0;     
    let currentChainMultiplier = 1.0;  
    let isHurryUpPlaying = false;  
    let timerInterval = null;
    
    // NUOVE Variabili per i livelli
    let currentLevel = 1;
    let levelStartScore = 0;
    let scoreToCompleteLevel = LEVEL_CONFIG[0].scoreToComplete;
    
    // NUOVO: Variabile per gestire la pausa
    let gamePaused = false;
    
    // Le consonanti attualmente disponibili per la scelta
    let availableConsonants = [];

    // Riferimenti UI - AGGIORNATI per i nuovi modal
    const ui = { 
        s: document.getElementById("score"), 
        w: document.getElementById("words"), 
        p: document.getElementById("pieces"), 
        lastWordVal: document.getElementById("last-word-val"),
        
        // Modali
        vowelModal: document.getElementById("vowel-modal"),
        consonantModal: document.getElementById("consonant-modal"),
        vowelTimer: document.getElementById("vowel-timer"),
        consonantTimer: document.getElementById("consonant-timer"),
        consonantButtons: document.getElementById("consonant-buttons"),
        
        // NUOVO: Riferimenti per la pausa
        pauseButton: document.getElementById("pause-button"),
        pauseOverlay: document.getElementById("pause-overlay"),
        resumeButton: document.getElementById("resume-button"),
        restartButton: document.getElementById("restart-button"),
        
        // NUOVO: Riferimenti per il livello
        levelIndicator: document.getElementById("level-indicator"),
        levelVal: document.getElementById("level"),
        levelProgressBar: document.getElementById("level-progress-bar"),
        
        // NUOVO: Riferimenti per overlay completamento livello
        levelCompleteOverlay: document.getElementById("level-complete-overlay"),
        currentLevelComplete: document.getElementById("current-level-complete"),
        levelScore: document.getElementById("level-score"),
        levelWords: document.getElementById("level-words"),
        nextLevelButton: document.getElementById("next-level-button")
    };

    function randSyl() {
        const rand = Math.random();
        
        if (rand < PROB_ONE_LETTER_SYL) {
            return SYLS_1_LETTER[Math.floor(Math.random() * SYLS_1_LETTER.length)];
        }
        else if (rand < PROB_ONE_LETTER_SYL + PROB_THREE_LETTER_SYL) {
            if (SYLS_3_LETTERS.length > 0) {
                return SYLS_3_LETTERS[Math.floor(Math.random() * SYLS_3_LETTERS.length)];
            }
        }
        
        if (SYLS_2_LETTERS.length > 0) {
            return SYLS_2_LETTERS[Math.floor(Math.random() * SYLS_2_LETTERS.length)];
        } else if (SYLS_3_LETTERS.length > 0) { 
            return SYLS_3_LETTERS[Math.floor(Math.random() * SYLS_3_LETTERS.length)];
        } else if (SYLS_1_LETTER.length > 0) {
            return SYLS_1_LETTER[Math.floor(Math.random() * SYLS_1_LETTER.length)];
        } else {
            console.error("ERRORE: Tutte le liste di sillabe sono vuote!");
            return "??"; 
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function selectRandomConsonants() {
        // Crea una copia delle consonanti e mischiala
        const shuffledConsonants = shuffleArray([...CONSONANTS]);
        
        // Scegli le prime NUM_CONSONANT_CHOICES consonanti
        return shuffledConsonants.slice(0, NUM_CONSONANT_CHOICES);
    }

    function setupConsonantSelection() {
        // Seleziona le consonanti casuali
        availableConsonants = selectRandomConsonants();
        
        // Ottieni il container per i pulsanti delle consonanti
        const buttonsContainer = ui.consonantButtons;
        
        // Rimuovi tutti i pulsanti esistenti
        while (buttonsContainer.firstChild) {
            buttonsContainer.removeChild(buttonsContainer.firstChild);
        }
        
        // Crea i nuovi pulsanti con le consonanti selezionate
        availableConsonants.forEach(consonant => {
            const button = document.createElement('button');
            button.className = 'selection-button consonant-button';
            button.setAttribute('data-consonant', consonant);
            button.textContent = consonant;
            button.addEventListener('click', e => {
                if (isChoiceActive&&!isVowelChoice) {
                    resolveChoice(e.target.getAttribute('data-consonant'));
                }
            });
            buttonsContainer.appendChild(button);
        });
    }

    // Aggiungi event listener ai pulsanti delle vocali
    document.querySelectorAll('.vowel-button').forEach(button => {
        button.addEventListener('click', e => {
            if (isChoiceActive&&isVowelChoice) {
                resolveChoice(e.target.getAttribute('data-vowel'));
            }
        });
    });

    function newPiece() {
        if (isNextPieceBomb) {
            isNextPieceBomb = false; 
            pieces++; ui.p.textContent = pieces;
            return { x: COLS >> 1, y: -1, h: 1, txt: ["💣"], isBomb: true, power: bombPower };
        }
        const r = Math.random(), h_normal = r < .3 ? 1 : r < .75 ? 2 : 3; const txt = [];
        while(txt.length < h_normal) { const s = randSyl(); if (!txt.includes(s)) txt.push(s); }
        pieces++; ui.p.textContent = pieces;
        
        if (txt.length > 0) {
            const sylIndexToMakeJoker = txt.length - 1; 
            const originalSyl = txt[sylIndexToMakeJoker];
            
            // Verifica se rendere un jolly di vocale
            if (/[AEIOU]$/.test(originalSyl)&&originalSyl.length > 1&&Math.random() < VOWEL_CHOICE_PROBABILITY) { 
                txt[sylIndexToMakeJoker] = originalSyl.slice(0, -1) + "*";
            }
            // Verifica se rendere un jolly di consonante (solo per vocali singole)
            else if (VOWELS.includes(originalSyl)&&Math.random() < CONSONANT_CHOICE_PROBABILITY) {
                txt[sylIndexToMakeJoker] = "*" + originalSyl;
            }
        }
        
        return { x: COLS >> 1, y: -h_normal, h: txt.length, txt, isBomb: false };
    }

    function canMove(p, dx, dy) {
        if (!p || isAnimatingClear) return false;
        for (let i = 0; i < p.h; i++) {
            const nx = p.x + dx, ny = p.y + i + dy;
            if (nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0&&board[ny][nx]&&board[ny][nx] !== 'CLEARING_PLACEHOLDER')) return false;
        }
        return true;
    }

    function lockCurrentPiece() { 
        if (!dizionarioPronto || isAnimatingClear) return;
        clearInterval(gameLoopTimer); 

        playSound('drop');

        if (cur.isBomb) {
            let landingRow = cur.y + cur.h - 1; 
            for(let i = cur.h -1; i >= 0; i--){ 
                if(cur.y + i >= ROWS -1 || (cur.y + i + 1 < ROWS&&board[cur.y + i + 1]&&board[cur.y + i + 1][cur.x])) { 
                    landingRow = cur.y + i; break;
                }
            }
            if (landingRow >= ROWS) landingRow = ROWS -1; 
            
            playSound('bombExplosion');
            
            detonateBomb(landingRow, cur.power, cur.x); 
            cur = null;
            processBoardAfterLock(); 
            return; 
        }

        let needsVowelChoice = false;
        let needsConsonantChoice = false;
        choiceCellInfo = null;
        
        for (let i = 0; i < cur.h; i++) {
            const r_lock = cur.y + i, c_lock = cur.x;
            if (r_lock < 0) { draw(); handleGameOver(); return; }
            board[r_lock][c_lock] = cur.txt[i];
        }
        
        for (let i = 0; i < cur.h; i++) {
            const r_check = cur.y + i, c_check = cur.x;
            if (r_check >= 0) {
                const cellContent = cur.txt[i];
                
                // Controlla i jolly di vocale (con * alla fine, es: "T*")
                if (cellContent.endsWith("*")) {
                    needsVowelChoice = true;
                    isVowelChoice = true;
                    choiceCellInfo = { r: r_check, c: c_check, prefix: cellContent.slice(0, -1) };
                    break;
                }
                // Controlla i jolly di consonante (con * all'inizio, es: "*A")
                else if (cellContent.startsWith("*")&&cellContent.length > 1) {
                    needsConsonantChoice = true;
                    isVowelChoice = false;
                    choiceCellInfo = { r: r_check, c: c_check, suffix: cellContent.slice(1) };
                    
                    // Prepara le consonanti disponibili per la selezione
                    setupConsonantSelection();
                    break;
                }
            }
        }
        
        cur = null; 
        draw(); 
        
        if (needsVowelChoice || needsConsonantChoice) {
            AudioSystem.playHurryUp();
            isHurryUpPlaying = true;
            
            isChoiceActive = true;
            
            if (needsVowelChoice) {
                // Mostra il modal delle vocali
                ui.vowelModal.style.display = "block";
                startTimer(true);
                document.addEventListener('keydown', handleVowelKeyboardChoice);
            } else {
                // Mostra il modal delle consonanti
                ui.consonantModal.style.display = "block";
                startTimer(false);
                document.addEventListener('keydown', handleConsonantKeyboardChoice);
            }
            
            clearTimeout(choiceTimerId);
            choiceTimerId = setTimeout(() => resolveChoice(null), VOWEL_TIMEOUT);
        } else {
            processBoardAfterLock();
        }
    }
    
    function startTimer(isVowel) {
        const timer = isVowel ? ui.vowelTimer : ui.consonantTimer;
        
        timer.style.width = "100%";
        timer.style.transition = `width ${VOWEL_TIMEOUT/1000}s linear`;
        
        void timer.offsetWidth; // Forza reflow
        
        timer.style.width = "0%";
    }
    
    function stopTimers() {
        // Nascondi entrambi i modali
        ui.vowelModal.style.display = "none";
        ui.consonantModal.style.display = "none";
        
        // Resetta i timer
        ui.vowelTimer.style.transition = "none";
        ui.vowelTimer.style.width = "100%";
        
        ui.consonantTimer.style.transition = "none";
        ui.consonantTimer.style.width = "100%";
    }

    function detonateBomb(bombHitRow, numRowsToClear, bombCol) {
        if (numRowsToClear <= 0) return;
        let actualRowsCleared = 0;
        for (let i = 0; i < numRowsToClear; i++) {
            const rowToClear = bombHitRow - i; 
            if (rowToClear >= 0&&rowToClear < ROWS) {
                for (let c = 0; c < COLS; c++) board[rowToClear][c] = null; 
                actualRowsCleared++; score += 50 * (i + 1); 
            } else break; 
        }
        // Aggiorna l'UI e verifica avanzamento livello
        updateScore();
    }

    function handleVowelKeyboardChoice(e) {
        if (!isChoiceActive || !isVowelChoice) return;
        const keyPressed = e.key.toUpperCase();
        if (VOWELS.includes(keyPressed)) {
            e.preventDefault();
            resolveChoice(keyPressed);
        }
    }
    
    function handleConsonantKeyboardChoice(e) {
        if (!isChoiceActive || isVowelChoice) return;
        const keyPressed = e.key.toUpperCase();
        if (availableConsonants.includes(keyPressed)) {
            e.preventDefault();
            resolveChoice(keyPressed);
        }
    }

    function resolveChoice(chosenLetter) {
        if (!isChoiceActive) return;
        clearTimeout(choiceTimerId);
        
        if (isVowelChoice) {
            document.removeEventListener('keydown', handleVowelKeyboardChoice);
        } else {
            document.removeEventListener('keydown', handleConsonantKeyboardChoice);
        }
        
        isChoiceActive = false;
        stopTimers();
        
        if (isHurryUpPlaying) {
            AudioSystem.stopHurryUp();
            isHurryUpPlaying = false;
        }
        
        if (!chosenLetter&&choiceCellInfo) {
            AudioSystem.playExplode();
            
            const { r, c } = choiceCellInfo;
            
            if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c]) {
                const cellContent = board[r][c];
                const isJollyVowel = cellContent.endsWith("*");
                const isJollyConsonant = cellContent.startsWith("*");
                
                if (isJollyVowel || isJollyConsonant) {
                    isAnimatingClear = true;
                    
                    const cellElement = $(idx(c, r));
                    if (cellElement) {
                        cellElement.classList.add('clearing');
                        board[r][c] = 'CLEARING_PLACEHOLDER';
                        
                        const jollyType = isJollyVowel ? "VOCALE" : "CONSONANTE";
                        ui.lastWordVal.innerHTML = `<span style="color:#f55">JOLLY ${jollyType} DISINTEGRATO!</span>`;
                        
                        setTimeout(() => {
                            if (board[r]&&board[r][c] === 'CLEARING_PLACEHOLDER') board[r][c] = null;
                            if (cellElement) {
                                cellElement.classList.remove('clearing');
                                cellElement.textContent = "";
                                cellElement.className = "cell";
                            }
                            isAnimatingClear = false;
                            processBoardAfterLock();
                        }, ANIMATION_CLEAR_DURATION);
                    }
                } else {
                    processBoardAfterLock();
                }
            } else {
                processBoardAfterLock();
            }
        } else if (chosenLetter&&choiceCellInfo) {
            if (isVowelChoice) {
                const { r, c, prefix } = choiceCellInfo;
                if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c] === prefix + "*") {
                    board[r][c] = prefix + chosenLetter;
                }
            } else { // Consonant choice
                const { r, c, suffix } = choiceCellInfo;
                if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c] === "*" + suffix) {
                    board[r][c] = chosenLetter + suffix;
                }
            }
            
            choiceCellInfo = null;
            draw();
            processBoardAfterLock();
        } else {
            choiceCellInfo = null;
            draw();
            processBoardAfterLock();
        }
    }

    function processBoardAfterLock() {
        if (!dizionarioPronto || gameIsOver) return; 
        if (isAnimatingClear) return; 
        
        pendingBoardUpdateAfterAnimation = false;
        let iterations = 0; const MAX_ITERATIONS = ROWS * COLS; 
        let stabilityReached = false;
        let wordFoundThisOverallPBALCycle = false;

        while (iterations < MAX_ITERATIONS&&!stabilityReached&&!gameIsOver&&!isAnimatingClear) {
            iterations++;
            if (gameIsOver) break;
            collapse(); draw();
            if (isAnimatingClear) break; 

            let wordFoundThisScanPass = false; 
            if (scanAndClearHorizontalWords()) { wordFoundThisScanPass = true; wordFoundThisOverallPBALCycle = true; }
            if (isAnimatingClear || gameIsOver) break;

            if (scanAndClearVerticalWords()) { wordFoundThisScanPass = true; wordFoundThisOverallPBALCycle = true; }
            if (isAnimatingClear || gameIsOver) break;

            if (!wordFoundThisScanPass) stabilityReached = true; 
        } 
        
        if (!isAnimatingClear&&!gameIsOver) {
            // Aggiorna l'UI e verifica avanzamento livello
            updateScore();
            
            cur = newPiece(); 
            
            if (cur.isBomb) { 
                currentDropInterval = Math.floor(START_DROP / 3);
            } else { 
                currentDropInterval = START_DROP;
            }

            if (!canMove(cur, 0, 0)) { draw(); handleGameOver(); return; }
            draw();
            if (!gameIsOver&&!gamePaused) {
                clearInterval(gameLoopTimer); 
                gameLoopTimer = setInterval(gameStep, currentDropInterval); 
            }
        }
    }
    
    // NUOVO: Funzione per aggiornare punteggio e verificare avanzamento livello
    function updateScore() {
        ui.s.textContent = score;
        ui.w.textContent = words;
        
        // Calcola il progresso del livello
        const levelProgress = Math.min(100, ((score - levelStartScore) / scoreToCompleteLevel) * 100);
        
        // Aggiorna la barra di progresso
        ui.levelProgressBar.style.width = `${levelProgress}%`;
        
        // Verifica se il livello è stato completato
        if (score >= (levelStartScore + scoreToCompleteLevel)) {
            // Livello completato!
            handleLevelComplete();
        }
    }
    
    // NUOVO: Gestione del livello completato
    function handleLevelComplete() {
        if (gameIsOver || isAnimatingClear) return;
        
        // Pausa il gioco
        gamePaused = true;
        clearInterval(gameLoopTimer);
        
        // Suono livello completato
        AudioSystem.playLevelUp();
        
        // Aggiorna l'UI dell'overlay
        ui.currentLevelComplete.textContent = currentLevel;
        ui.levelScore.textContent = score;
        ui.levelWords.textContent = words;
        
        // Mostra l'overlay
        ui.levelCompleteOverlay.style.display = "flex";
    }
    
    // NUOVO: Passa al livello successivo
    function startNextLevel() {
        if (currentLevel >= LEVEL_CONFIG.length) {
            // Hai completato tutti i livelli!
            alert("Congratulazioni! Hai completato tutti i livelli del gioco!");
            loadDictionaryAndInitGame(); // Ricomincia dal livello 1
            return;
        }
        
        currentLevel++;
        const levelConfig = LEVEL_CONFIG[currentLevel - 1];
        
        // Nascondi l'overlay
        ui.levelCompleteOverlay.style.display = "none";
        
        // Aggiorna le variabili del livello
        ROWS = levelConfig.rows;
        COLS = levelConfig.columns;
        START_DROP = levelConfig.startDropInterval;
        currentDropInterval = START_DROP;
        
        // Aggiorna le probabilità
        PROB_ONE_LETTER_SYL = levelConfig.syls1LetterProb;
        PROB_THREE_LETTER_SYL = levelConfig.syls3LetterProb;
        VOWEL_CHOICE_PROBABILITY = levelConfig.vowelJokerProb;
        CONSONANT_CHOICE_PROBABILITY = levelConfig.consonantJokerProb;
        
        // Salva il punteggio attuale come inizio del nuovo livello
        levelStartScore = score;
        scoreToCompleteLevel = levelConfig.scoreToComplete;
        
        // Aggiorna l'UI del livello
        ui.levelVal.textContent = currentLevel;
        ui.levelIndicator.textContent = `Livello ${currentLevel}`;
        ui.levelProgressBar.style.width = "0%";
        
        // Ricrea la griglia con le nuove dimensioni
        recreateGameGrid();
        
        // Ricrea il board con le nuove dimensioni
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        
        // Aggiorna la funzione di selezione celle in base alle nuove dimensioni
        $ = function(q) { 
            return document.querySelectorAll("#game .cell")[q];
        };
        
        // Ricrea un pezzo e riprendi il gioco
        cur = newPiece();
        draw();
        
        gamePaused = false;
        gameLoopTimer = setInterval(gameStep, currentDropInterval);
    }
    
    // NUOVO: Funzione per ricreare la griglia di gioco
    function recreateGameGrid() {
        // Svuota il contenitore
        gameElement.innerHTML = '';
        
        // Aggiorna lo stile CSS per le nuove dimensioni
        gameElement.style.gridTemplateColumns = `repeat(${COLS}, 38px)`;
        
        // Crea le nuove celle
        for (let i = 0; i < ROWS * COLS; i++) {
            const d = document.createElement("div");
            d.className = "cell";
            gameElement.appendChild(d);
        }
    }

    function scanAndClearHorizontalWords() {
        if (gameIsOver || isAnimatingClear) return false; let clearedAny = false;
        for (let r = 0; r < ROWS; r++) {
            let currentRun = [];
            for (let c = 0; c < COLS; c++) {
                const cellContent = board[r][c];
                // Modifica per escludere sia i jolly di vocale che quelli di consonante
                if (cellContent&&!cellContent.endsWith("*")&&!cellContent.startsWith("*")&&cellContent !== 'CLEARING_PLACEHOLDER') {
                    currentRun.push({syl: cellContent, c: c });
                } else { 
                    if (currentRun.length >= 2&&processRunForWords(currentRun, r, true)) clearedAny = true;
                    currentRun = []; 
                }
                if (isAnimatingClear) break; 
            }
            if (isAnimatingClear) break;
            if (currentRun.length >= 2&&processRunForWords(currentRun, r, true)) clearedAny = true;
        }
        return clearedAny;
    }

    function scanAndClearVerticalWords() {
        if (gameIsOver || isAnimatingClear) return false; let clearedAny = false;
        for (let c = 0; c < COLS; c++) {
            let currentRun = [];
            for (let r = 0; r < ROWS; r++) {
                const cellContent = board[r][c];
                // Modifica per escludere sia i jolly di vocale che quelli di consonante
                if (cellContent&&!cellContent.endsWith("*")&&!cellContent.startsWith("*")&&cellContent !== 'CLEARING_PLACEHOLDER') {
                    currentRun.push({syl: cellContent, r: r });
                } else { 
                    if (currentRun.length >= 2&&processRunForWords(currentRun, c, false)) clearedAny = true; 
                    currentRun = []; 
                }
                if (isAnimatingClear) break;
            }
            if (isAnimatingClear) break;
            if (currentRun.length >= 2&&processRunForWords(currentRun, c, false)) clearedAny = true;
        }
        return clearedAny;
    }

    function processRunForWords(run, fixedCoord, isHorizontal) {
        if (gameIsOver || isAnimatingClear) return false;
        for (let len = run.length; len >= 2; len--) {
            for (let i = 0; i <= run.length - len; i++) {
                const subRun = run.slice(i, i + len); const wordAttempt = subRun.map(item => item.syl).join("");
                if (DICT.has(wordAttempt)) {
                    let cellsAreValid = true;
                    for(const item of subRun) { const r_val = isHorizontal ? fixedCoord : item.r; const c_val = isHorizontal ? item.c : fixedCoord; if(!board[r_val] || board[r_val][c_val] !== item.syl || board[r_val][c_val] === 'CLEARING_PLACEHOLDER') { cellsAreValid = false; break; }}
                    if(cellsAreValid) {
                        playSound('word');
                        
                        isAnimatingClear = true; clearInterval(gameLoopTimer);
                        const cellsToAnimate = [];
                        for (const item of subRun) { const r_anim = isHorizontal ? fixedCoord : item.r; const c_anim = isHorizontal ? item.c : fixedCoord; const cellElement = $(idx(c_anim, r_anim)); if (cellElement) { cellElement.classList.add('clearing'); cellsToAnimate.push({ r:r_anim, c:c_anim }); board[r_anim][c_anim] = 'CLEARING_PLACEHOLDER'; }}
                        
                        const numberOfSyllablesInGrid = subRun.length;
                        let bombaAttivataQuestoTurno = false;
                        if (numberOfSyllablesInGrid >= 3&&!isNextPieceBomb) { 
                            isNextPieceBomb = true;
                            bombPower = numberOfSyllablesInGrid - 2;
                            bombaAttivataQuestoTurno = true;
                        }
                        
                        // MODIFICATO: Punti in base alla lunghezza della parola, moltiplicati per il livello attuale
                        const wordScore = wordAttempt.length * 10 * currentLevel;
                        score += wordScore;
                        words++;
                        
                        if (bombaAttivataQuestoTurno) {
                            ui.lastWordVal.innerHTML = wordAttempt + `<br><span style="color:orange;font-weight:bold;">BOMBA PRONTA! (${bombPower} righe)</span>`;
                        } else {
                            ui.lastWordVal.textContent = wordAttempt;
                        }
                        
                        setTimeout(() => {
                            cellsToAnimate.forEach(cellCoords => { if (board[cellCoords.r]&&board[cellCoords.r][cellCoords.c] === 'CLEARING_PLACEHOLDER') board[cellCoords.r][cellCoords.c] = null; const el = $(idx(cellCoords.c, cellCoords.r)); if (el) { el.classList.remove('clearing'); el.textContent = ""; el.className = "cell"; }});
                            isAnimatingClear = false; pendingBoardUpdateAfterAnimation = true;
                            if (!gameIsOver) processBoardAfterLock(); else draw(); 
                        }, ANIMATION_CLEAR_DURATION);
                        return true; 
                    }
                }
            }
        }
        return false;
    }

    function collapse() {
        if (gameIsOver || isAnimatingClear) return;
        for (let c = 0; c < COLS; c++) {
            let emptyRow = ROWS - 1;
            for (let r = ROWS - 1; r >= 0; r--) {
                const cellContent = board[r][c];
                if (cellContent&&cellContent !== 'CLEARING_PLACEHOLDER') {
                    if (r !== emptyRow) { board[emptyRow][c] = board[r][c]; board[r][c] = null; }
                    emptyRow--;
                }
            }
        }
    }

    function draw() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cellElement = $(idx(c, r));
                if (cellElement) {
                    const s_board = board[r][c];
                    if (s_board === 'CLEARING_PLACEHOLDER') { if(!cellElement.classList.contains('clearing')) {} continue; }
                    cellElement.textContent = s_board || "";
                    if (s_board) {
                        if (s_board === "💣") { 
                            cellElement.className = "cell bomb-cell";
                        } else if (s_board.endsWith("*")) {
                            cellElement.className = "cell joker-cell";
                        } else if (s_board.startsWith("*")) {
                            cellElement.className = "cell consonant-joker-cell";
                        } else {
                            cellElement.className = "cell filled";
                        }
                    } else {
                        cellElement.className = "cell";
                    }
                }
            }
        }
        if (cur&&!gameIsOver&&!isAnimatingClear) {
            cur.txt.forEach((s_cur, i) => {
                const r_cur = cur.y + i;
                if (r_cur >= 0&&r_cur < ROWS) {
                    const cellElement = $(idx(cur.x, r_cur));
                    if (cellElement) { 
                        if (board[r_cur]&&board[r_cur][cur.x] === 'CLEARING_PLACEHOLDER') return;
                        cellElement.textContent = s_cur; 
                        if (cur.isBomb) { 
                            cellElement.className = "cell bomb-cell";
                        } else if (s_cur.endsWith("*")) { 
                            cellElement.className = "cell joker-cell";
                        } else if (s_cur.startsWith("*")) {
                            cellElement.className = "cell consonant-joker-cell";
                        } else { 
                            cellElement.className = "cell filled";
                        }
                    }
                }
            });
        }
    }

    function gameStep() {
        if (isChoiceActive || gameIsOver || !cur || !dizionarioPronto || isAnimatingClear || gamePaused) return;
        if (canMove(cur, 0, 1)) cur.y++; else lockCurrentPiece(); 
        if (cur&&!gameIsOver&&!isAnimatingClear) draw();
    }

    function handleMove(direction) {
        if (isChoiceActive || gameIsOver || !cur || !dizionarioPronto || isAnimatingClear || gamePaused) return;
        
        let moved = false;
        const currentPieceCells = [];
        
        if (cur.isBomb) { 
            if (direction === 'left'&&canMove(cur, -1, 0)) { cur.x--; moved = true; }
            else if (direction === 'right'&&canMove(cur, 1, 0)) { cur.x++; moved = true; }
            else if (direction === 'down'&&canMove(cur, 0, 1)) { cur.y++; moved = true; }
        } else { 
            if (direction === 'left'&&canMove(cur, -1, 0)) { cur.x--; moved = true; }
            else if (direction === 'right'&&canMove(cur, 1, 0)) { cur.x++; moved = true; }
            else if (direction === 'down'&&canMove(cur, 0, 1)) { cur.y++; moved = true; } 
            else if (direction === 'rotate'&&cur.txt.length > 1) { cur.txt.unshift(cur.txt.pop()); moved = true; }
        }

        if(moved&&!gameIsOver&&!isAnimatingClear) {
            cur.txt.forEach((s_cur, i) => { 
                const r_cur = cur.y + i; 
                if (r_cur >= 0&&r_cur < ROWS) { 
                    const cellElement = $(idx(cur.x, r_cur)); 
                    if (cellElement&&(!board[r_cur] || board[r_cur][cur.x] !== 'CLEARING_PLACEHOLDER')) 
                        currentPieceCells.push(cellElement); 
                }
            });
            
            currentPieceCells.forEach(el => el.classList.add('piece-moved-feedback'));
            draw();
            setTimeout(() => currentPieceCells.forEach(el => el.classList.remove('piece-moved-feedback')), 100);
        }
    }

    // NUOVA FUNZIONE: Gestione pause
    function togglePause() {
        // Non mettere in pausa se siamo in una scelta jolly
        if (isChoiceActive) return;
        
        gamePaused = !gamePaused;
        
        if (gamePaused) {
            // Metti in pausa il gioco
            clearInterval(gameLoopTimer);
            ui.pauseOverlay.style.display = 'flex';
            
            // Ferma l'audio di hurry-up se in riproduzione
            if (isHurryUpPlaying) {
                AudioSystem.stopHurryUp();
            }
        } else {
            // Riprendi il gioco
            ui.pauseOverlay.style.display = 'none';
            
            if (!gameIsOver&&!isAnimatingClear&&cur) {
                gameLoopTimer = setInterval(gameStep, currentDropInterval);
                
                // Riprendi l'audio di hurry-up se era in riproduzione
                if (isHurryUpPlaying) {
                    AudioSystem.playHurryUp();
                }
            }
        }
    }

    function setupTouchControls() {
        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('#touch-controls')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.getElementById('touch-left').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('left');
            startRepeatMove('left');
        });
        
        document.getElementById('touch-right').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('right');
            startRepeatMove('right');
        });
        
        document.getElementById('touch-down').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('down');
            startRepeatMove('down');
        });
        
        document.getElementById('touch-rotate').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('rotate');
        });
        
        const touchButtons = document.querySelectorAll('.touch-button');
        touchButtons.forEach(button => {
            button.addEventListener('touchend', stopRepeatMove);
            button.addEventListener('touchcancel', stopRepeatMove);
        });
    }
    
    let repeatMoveTimer = null;
    
    function startRepeatMove(direction) {
        stopRepeatMove();
        repeatMoveTimer = setInterval(() => {
            handleMove(direction);
        }, 150);
    }
    
    function stopRepeatMove() {
        if (repeatMoveTimer) {
            clearInterval(repeatMoveTimer);
            repeatMoveTimer = null;
        }
    }

    document.addEventListener("keydown", e => {
        const activeElement = document.activeElement;
        if (activeElement&&(activeElement.id === 'music-volume' || activeElement.id === 'sfx-volume')) {
            if (e.code === "ArrowLeft" || e.code === "ArrowRight" || 
                e.code === "ArrowUp" || e.code === "ArrowDown") {
                activeElement.blur();
            }
        }
        
        // Gestione tasto P per pausa
        if (e.code === "KeyP" || e.code === "Escape") {
            togglePause();
            return;
        }
        
        // Non permettere movimenti quando in pausa
        if (gamePaused) return;
        
        if (e.code === "ArrowLeft") handleMove('left');
        else if (e.code === "ArrowRight") handleMove('right');
        else if (e.code === "ArrowDown") handleMove('down');
        else if (e.code === "ArrowUp") handleMove('rotate');
    });

    function applyDeviceSpecificOptimizations() {
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const pixelRatio = window.devicePixelRatio || 1;
        
        // Rileva iPhone di nuova generazione
        const isNewIPhone = 
            (window.screen.height === 844&&window.screen.width === 390) || // iPhone 12, 13
            (window.screen.height === 926&&window.screen.width === 428) || // iPhone 12 Pro Max, 13 Pro Max
            (window.screen.height === 812&&window.screen.width === 375) || // iPhone X, XS, 11 Pro
            (window.screen.height === 896&&window.screen.width === 414);   // iPhone XR, XS Max, 11
        
        if (isNewIPhone) {
            document.body.classList.add('iphone-optimized');
            
            // Regola i margini e spaziature per iPhone recenti
            const statsCol = document.querySelector('.stats-column');
            if (statsCol) {
                statsCol.style.marginBottom = '8px';
            }
            
            // Aumenta un po' i pulsanti touch per adattarli meglio all'iPhone
            const touchButtons = document.querySelectorAll('.touch-button');
            touchButtons.forEach(button => {
                button.style.width = '55px';
                button.style.height = '55px';
            });
        }
        
        // Rileva dispositivi specifici problematici
        const isSmallOlderDevice = 
            (screenWidth <= 375&&screenHeight <= 667) || // iPhone 8/7/6
            (screenWidth <= 360&&screenHeight <= 640) || // Samsung vecchi modelli
            (screenWidth <= 320);                          // Dispositivi molto piccoli
        
        // Rileva specificamente Galaxy Watch Active 3 e simili
        const isGalaxyWatchActive = 
            (screenWidth <= 360&&screenHeight <= 360)&&(navigator.userAgent.includes('SM-R') || // Identificatore tipico dei Galaxy Watch
            (screenWidth === screenHeight));        // Schermo quadrato/rotondo
        
        if (isGalaxyWatchActive) {
            document.body.classList.add('galaxy-watch-optimized');
            
            // Ottimizzazioni estreme per smartwatch
            const gameElement = document.getElementById("game");
            if (gameElement) {
                gameElement.style.gridTemplateColumns = "repeat(10, 20px)";
                gameElement.style.gridAutoRows = "20px";
            }
        }
        else if (isSmallOlderDevice) {
            // Applica class speciale al body per CSS mirato
            document.body.classList.add('small-device-optimized');
            
            // Regolazioni dinamiche minime solo per i dispositivi problematici
            const gameElement = document.getElementById("game");
            if (gameElement) {
                // Riduci leggermente la dimensione della griglia solo su questi dispositivi
                const cellSize = screenWidth <= 320 ? 22 : 24;
                gameElement.style.gridTemplateColumns = `repeat(10, ${cellSize}px)`;
                gameElement.style.gridAutoRows = `${cellSize}px`;
            }
            
            // Compatta lo spazio delle statistiche solo se necessario
            const statsColumn = document.querySelector(".stats-column");
            if (statsColumn) {
                statsColumn.style.padding = "3px";
                statsColumn.style.gap = "3px";
            }
        }
    }

    function initializeActualGame() {
        if (!dizionarioPronto) { console.error("InitializeActualGame: Dizionario non pronto."); return; }
        
        // Azzera tutte le variabili
        gameIsOver = false; 
        isChoiceActive = false; 
        isVowelChoice = false; 
        isAnimatingClear = false; 
        pendingBoardUpdateAfterAnimation = false;
        isNextPieceBomb = false; 
        bombPower = 0; 
        chainCount = 0; 
        currentChainMultiplier = 1.0; 
        isHurryUpPlaying = false;
        gamePaused = false;
        
        // NUOVO: Inizializza il livello
        currentLevel = 1;
        const levelConfig = LEVEL_CONFIG[currentLevel - 1];
        
        // Aggiorna le dimensioni
        ROWS = levelConfig.rows;
        COLS = levelConfig.columns;
        START_DROP = levelConfig.startDropInterval;
        
        // Aggiorna le probabilità
        PROB_ONE_LETTER_SYL = levelConfig.syls1LetterProb;
        PROB_THREE_LETTER_SYL = levelConfig.syls3LetterProb;
        VOWEL_CHOICE_PROBABILITY = levelConfig.vowelJokerProb;
        CONSONANT_CHOICE_PROBABILITY = levelConfig.consonantJokerProb;
        
        // Aggiorna l'UI del livello
        ui.levelVal.textContent = currentLevel;
        ui.levelIndicator.textContent = `Livello ${currentLevel}`;
        ui.levelProgressBar.style.width = "0%";
        
        levelStartScore = 0;
        scoreToCompleteLevel = levelConfig.scoreToComplete;

        stopTimers();

        // Nascondi overlay di pausa se visibile
        ui.pauseOverlay.style.display = 'none';
        
        // Nascondi overlay di livello completato se visibile
        ui.levelCompleteOverlay.style.display = 'none';

        clearTimeout(choiceTimerId);
        if (document.activeElement&&typeof document.activeElement.blur === 'function') document.activeElement.blur();
        document.removeEventListener('keydown', handleVowelKeyboardChoice);
        document.removeEventListener('keydown', handleConsonantKeyboardChoice);
        
        // Ricrea la griglia con le nuove dimensioni
        recreateGameGrid();
        
        // Inizializza il board
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        
        // Aggiorna la funzione di selezione celle in base alle nuove dimensioni
        $ = function(q) { 
            return document.querySelectorAll("#game .cell")[q];
        };
        
        score = 0; words = 0; pieces = 0; 
        ui.s.textContent = 0; 
        ui.w.textContent = 0; 
        ui.p.textContent = 0; 
        ui.lastWordVal.textContent = "---";
        
        cur = newPiece(); 
        if (cur.isBomb) { 
            currentDropInterval = Math.floor(START_DROP / 3);
        } else { 
            currentDropInterval = START_DROP;
        }
        
        draw();
        clearInterval(gameLoopTimer);
        if (!isAnimatingClear&&!gameIsOver) { 
            gameLoopTimer = setInterval(gameStep, currentDropInterval); 
        }
        
        AudioSystem.initialize();
        setupTouchControls();
    }

    function handleGameOver() {
        if (gameIsOver) return; gameIsOver = true; 
        clearInterval(gameLoopTimer); clearTimeout(choiceTimerId);
        
        stopTimers();
        
        if (isHurryUpPlaying) {
            AudioSystem.stopHurryUp();
            isHurryUpPlaying = false;
        }
        
        if (isChoiceActive) { 
            document.removeEventListener('keydown', handleVowelKeyboardChoice);
            document.removeEventListener('keydown', handleConsonantKeyboardChoice);
            isChoiceActive = false;
        }
        draw(); 
        setTimeout(() => { 
            alert(`GAME OVER\nLivello: ${currentLevel}\nPunti ${score}\nParole ${words}\nPezzi ${pieces}`); 
            loadDictionaryAndInitGame(); 
        }, 100 + (isAnimatingClear ? ANIMATION_CLEAR_DURATION : 0) );
    }

    async function loadDictionaryAndInitGame() {
        gameIsOver = false; isAnimatingClear = false; pendingBoardUpdateAfterAnimation = false; clearInterval(gameLoopTimer);
        DICT.clear(); dizionarioPronto = false; 
        ui.lastWordVal.textContent = "CARICAMENTO...";
        try {
            const response = await fetch('data/dizionario.txt');
            if (!response.ok) throw new Error(`Errore HTTP! Status: ${response.status} (${response.statusText}) per data/dizionario.txt`);
            const text = await response.text(); const paroleCaricate = text.trim().split(/\r?\n/);
            paroleCaricate.forEach(word => { const parolaPulita = word.trim().toUpperCase(); if (parolaPulita.length > 0) DICT.add(parolaPulita); });
            if (DICT.size === 0&&paroleCaricate.length > 0) console.warn("Dizionario caricato ma DICT è vuoto.");
            else if (DICT.size === 0) console.warn("Nessuna parola caricata nel dizionario.");
            dizionarioPronto = true; ui.lastWordVal.textContent = "---"; initializeActualGame();
        } catch (error) { console.error("Impossibile caricare il dizionario:", error); alert("Errore caricamento dizionario: " + error.message + "\nControlla console."); ui.lastWordVal.textContent = "ERRORE DIZIONARIO"; }
    }
    
    // NUOVO: Gestione pausa automatica quando la pagina va in background
    document.addEventListener('visibilitychange', () => {
        if (document.hidden&&!gameIsOver&&!gamePaused&&dizionarioPronto) {
            // Metti in pausa quando l'utente lascia la pagina
            togglePause();
        }
    });
    
    // NUOVO: Event listener per i pulsanti di pausa
    ui.pauseButton.addEventListener('click', togglePause);
    ui.resumeButton.addEventListener('click', togglePause);
    ui.restartButton.addEventListener('click', () => {
        gamePaused = false;
        ui.pauseOverlay.style.display = 'none';
        loadDictionaryAndInitGame();
    });
    
    // NUOVO: Event listener per il pulsante passa al livello successivo
    ui.nextLevelButton.addEventListener('click', startNextLevel);
    
    document.getElementById('start-game-button').addEventListener('click', function() {
        document.getElementById('audio-start-overlay').style.display = 'none';
        
        AudioSystem.backgroundMusicActive = true;
        AudioSystem.initialize();
        
        // Applica ottimizzazioni specifiche per il dispositivo
        applyDeviceSpecificOptimizations();
        setupGameDimensions();
        
        loadDictionaryAndInitGame();
    });

    function setupGameDimensions() {
        // Utilizza rilevamento dinamico per determinare se siamo su iPhone di nuova generazione
        const isNewIPhone = 
            (window.screen.height === 844&&window.screen.width === 390) || // iPhone 12, 13
            (window.screen.height === 926&&window.screen.width === 428) || // iPhone 12 Pro Max, 13 Pro Max
            (window.screen.height === 812&&window.screen.width === 375) || // iPhone X, XS, 11 Pro
            (window.screen.height === 896&&window.screen.width === 414);   // iPhone XR, XS Max, 11
        
        if (isNewIPhone) {
            document.body.classList.add('iphone-optimized');
            
            // Regola i margini e spaziature per iPhone recenti
            const statsCol = document.querySelector('.stats-column');
            if (statsCol) {
                statsCol.style.marginBottom = '8px';
            }
            
            // Aumenta un po' i pulsanti touch per adattarli meglio all'iPhone
            const touchButtons = document.querySelectorAll('.touch-button');
            touchButtons.forEach(button => {
                button.style.width = '55px';
                button.style.height = '55px';
            });
        }
    }

    // Applica ottimizzazioni quando la pagina viene caricata
    document.addEventListener('DOMContentLoaded', function() {
        // Le ottimizzazioni verranno applicate più tardi quando il gioco viene avviato
    });

    // Gestisci gli adattamenti anche durante il ridimensionamento
    window.addEventListener('resize', function() {
        // Riapplica le ottimizzazioni in caso di cambio orientamento
        if (!document.getElementById('audio-start-overlay').style.display === 'none') {
            applyDeviceSpecificOptimizations();
            setupGameDimensions();
        }
    });
</script>
</body>
</html>