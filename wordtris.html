<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WordTris</title>
    <style>
        body { background: #111; color: #eee; font-family: sans-serif; text-align: center; margin: 0; padding-bottom: 80px; }
        
        /* GRIGLIA AUMENTATA DEL 20% */
        #game { 
            margin: 10px auto 5px; 
            display: inline-grid; 
            grid-template-columns: repeat(10, 38px); /* Aumentato da 32px a 38px */
            grid-auto-rows: 38px; /* Aumentato da 32px a 38px */
            gap: 2px; 
            background: #2a2a2a; 
            padding: 2px; 
            border: 3px solid #555; 
            border-radius: 8px; 
        }
        
        .cell { 
            background: #383838; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font: 600 18px monospace; /* Aumentato da 15px a 18px */
            overflow: hidden; 
            user-select: none; 
            border-radius: 5px; 
            box-shadow: inset 0 0 4px rgba(0,0,0,0.2), 0 1px 2px rgba(0,0,0,0.3); 
            transition: background-color 0.2s ease-out, transform 0.1s ease-out, box-shadow 0.2s ease-out; 
        }
        
        .filled { background: linear-gradient(145deg, #3ab0c0, #2f8a9a); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.2), inset 0 -1px 1px rgba(0,0,0,0.1), 0 2px 3px rgba(0,0,0,0.4); }
        .joker-cell { background: linear-gradient(145deg, #e04040, #b30000); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 2px 3px rgba(0,0,0,0.5), 0 0 6px rgba(255, 80, 80, 0.6); }
        .consonant-joker-cell { background: linear-gradient(145deg, #9040e0, #6000b3); color: #fff; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 2px 3px rgba(0,0,0,0.5), 0 0 6px rgba(160, 80, 255, 0.6); }
        .bomb-cell { background: linear-gradient(145deg, #555, #222); color: #ffcc00; font-size: 24px; border: 2px outset #777; box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), inset 0 -1px 1px rgba(0,0,0,0.2), 0 3px 5px rgba(0,0,0,0.6), 0 0 10px rgba(255, 165, 0, 0.7); }
        .cell.clearing { animation: cellClearAnimation 0.5s forwards; position: relative; z-index: 100; }
        @keyframes cellClearAnimation { 0% { transform: scale(1.0); opacity: 1; background-color: #ffdd40; box-shadow: 0 0 15px #ffdd40; } 50% { transform: scale(1.2); opacity: 0.8; } 100% { transform: scale(0.3); opacity: 0; background-color: transparent; box-shadow: none; } }
        .piece-moved-feedback { outline: 1px solid rgba(255, 255, 0, 0.7); transition: outline 0.05s linear; }
        #info { margin: 5px; font-size: 15px; line-height: 1.2; }
        #vowel-selection, #consonant-selection { display: none; margin-top: 10px; font-size: 13px; }
        .vowel, .consonant { cursor: pointer; display: inline-block; padding: 10px; margin: 5px; background: #666; border-radius: 5px; color: white; box-shadow: 0 2px 3px rgba(0,0,0,0.3); }
        .vowel:hover, .consonant:hover { background: #888; transform: translateY(-1px); }
        .vowel:active, .consonant:active { transform: translateY(0px); box-shadow: inset 0 1px 2px rgba(0,0,0,0.3); }
        span.val { font-weight: bold; color: #7f7; }
        #last-word-display { margin-top: 5px; font-size: 15px; color: #ccc; min-height: 2.2em; line-height: 1.2em; }
        #last-word-display .val { color: #fa0; }
        
        /* Timer per la selezione */
        #vowel-timer-container, #consonant-timer-container {
            width: 200px;
            height: 10px;
            background: #333;
            margin: 15px auto 5px;
            border-radius: 5px;
            overflow: hidden;
            display: none;
        }
        #vowel-timer, #consonant-timer {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #2a8, #fa0 40%, #f50 70%, #f00);
            border-radius: 5px;
            transition: width linear;
        }
        
        /* Controllo audio semplificato */
        #audio-controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
        }
        #toggle-music {
            background: rgba(40, 40, 40, 0.8);
            color: #fff;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #toggle-music.active {
            background: rgba(42, 136, 110, 0.8);
        }
        #toggle-music:hover {
            background: rgba(60, 60, 60, 0.9);
        }
        #toggle-music.active:hover {
            background: rgba(52, 166, 140, 0.9);
        }
        
        /* Indicatore di feedback audio */
        #sound-indicator { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 5px 10px; border-radius: 5px; font-size: 12px; opacity: 0; transition: opacity 0.2s ease; }
        #sound-indicator.active { opacity: 1; }
        
        /* Stato di caricamento audio */
        #audio-loading {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: #ff6;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        #audio-loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* Stile per l'overlay di avvio */
        #audio-start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }
        #audio-start-overlay h2 {
            font-size: 36px;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(255,255,255,0.2);
        }
        #audio-start-overlay p {
            font-size: 16px;
            max-width: 500px;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.4;
            padding: 0 15px;
        }
        
        #audio-start-overlay .start-logo {
            max-width: 250px;
            height: auto;
            margin-bottom: 15px;
        }
        
        #start-game-button {
            padding: 12px 24px;
            margin: 15px 0;
            font-size: 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            font-weight: bold;
            background: linear-gradient(145deg, #3ab0c0, #2a8);
            color: white;
        }
        
        #start-game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        #start-game-button:active {
            transform: translateY(0);
        }

        /* Controlli touch ottimizzati */
        #touch-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 5px 0;
            background: rgba(20, 20, 20, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            z-index: 1000;
            box-shadow: 0 -3px 10px rgba(0,0,0,0.4);
        }

        .touch-button {
            width: 60px;
            height: 60px;
            background: rgba(60, 60, 60, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            transition: all 0.1s ease;
        }

        .touch-button:active {
            background: rgba(100, 100, 100, 0.9);
            transform: scale(0.95);
            box-shadow: 0 1px 3px rgba(0,0,0,0.4);
        }

        /* Media queries per dispositivi mobili */
        @media (max-width: 768px) {
            #game {
                grid-template-columns: repeat(10, 34px); /* Aumentato da 28px a 34px */
                grid-auto-rows: 34px; /* Aumentato da 28px a 34px */
                gap: 1px;
                margin-top: 5px;
            }
            
            .cell {
                font-size: 14px; /* Aumentato da 12px a 14px */
            }
            
            .touch-button {
                width: 52px;
                height: 52px;
                font-size: 20px;
            }
            
            #info {
                margin: 4px;
                font-size: 14px;
            }
            
            #last-word-display {
                font-size: 14px;
                min-height: 2em;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding-bottom: 70px;
            }
            
            #game {
                grid-template-columns: repeat(10, 29px); /* Aumentato da 24px a 29px */
                grid-auto-rows: 29px; /* Aumentato da 24px a 29px */
                margin-top: 3px;
            }
            
            .cell {
                font-size: 12px; /* Aumentato da 10px a 12px */
            }
            
            .touch-button {
                width: 48px;
                height: 48px;
                font-size: 18px;
            }
            
            #touch-controls {
                padding: 3px 0;
            }
            
            #toggle-music {
                font-size: 12px;
                padding: 6px 10px;
            }
        }
        
        /* Ulteriori ottimizzazioni per schermi molto piccoli */
        @media (max-width: 360px) {
            #game {
                grid-template-columns: repeat(10, 26px); /* Aumentato da 22px a 26px */
                grid-auto-rows: 26px; /* Aumentato da 22px a 26px */
            }
            
            .cell {
                font-size: 11px; /* Aumentato da 10px a 11px */
            }
            
            .touch-button {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
            
            #info, #last-word-display {
                font-size: 12px;
            }
        }

        /* Nasconde i controlli touch quando è disponibile un mouse */
        @media (hover: hover) and (pointer: fine) {
            #touch-controls {
                display: none;
            }
            
            body {
                padding-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Overlay per l'avvio dell'audio -->
    <div id="audio-start-overlay">
        <img src="img/logo.png" alt="WordTris Logo" class="start-logo">
        <h2>WordTris</h2>
        <p>Un gioco di parole ispirato a Tetris. Componi parole italiane usando le sillabe che cadono!</p>
        <button id="start-game-button">Inizia</button>
    </div>

    <div id="game"></div>
    <div id="info">Punti <span id="score" class="val">0</span> · Parole <span id="words" class="val">0</span> · Pezzi <span id="pieces" class="val">0</span></div>
    <div id="last-word-display">Ultima Parola: <span id="last-word-val" class="val">---</span></div>
    
    <!-- Controlli audio semplificati -->
    <div id="audio-controls">
        <button id="toggle-music" class="active">Musica: ON</button>
    </div>
    
    <div id="vowel-timer-container">
        <div id="vowel-timer"></div>
    </div>
    
    <div id="consonant-timer-container">
        <div id="consonant-timer"></div>
    </div>
    
    <div id="vowel-selection">
        Scegli una vocale (o premi A,E,I,O,U): <br>
        <div class="vowel" data-vowel="A">A</div>
        <div class="vowel" data-vowel="E">E</div>
        <div class="vowel" data-vowel="I">I</div>
        <div class="vowel" data-vowel="O">O</div>
        <div class="vowel" data-vowel="U">U</div>
    </div>
    
    <div id="consonant-selection">
        Scegli una consonante: <br>
        <div class="consonant" data-consonant="B">B</div>
        <div class="consonant" data-consonant="C">C</div>
        <div class="consonant" data-consonant="D">D</div>
        <div class="consonant" data-consonant="F">F</div>
        <div class="consonant" data-consonant="G">G</div>
        <div class="consonant" data-consonant="H">H</div>
        <div class="consonant" data-consonant="L">L</div>
        <div class="consonant" data-consonant="M">M</div>
        <div class="consonant" data-consonant="N">N</div>
        <div class="consonant" data-consonant="P">P</div>
        <div class="consonant" data-consonant="Q">Q</div>
        <div class="consonant" data-consonant="R">R</div>
        <div class="consonant" data-consonant="S">S</div>
        <div class="consonant" data-consonant="T">T</div>
        <div class="consonant" data-consonant="V">V</div>
        <div class="consonant" data-consonant="Z">Z</div>
    </div>
    
    <div id="sound-indicator">♪</div>
    <div id="audio-loading">Caricamento audio...</div>
    
    <!-- Controlli touch per dispositivi mobili -->
    <div id="touch-controls">
        <div class="touch-button" id="touch-left">⬅️</div>
        <div class="touch-button" id="touch-rotate">🔄</div>
        <div class="touch-button" id="touch-right">➡️</div>
        <div class="touch-button" id="touch-down">⬇️</div>
    </div>
    
    <!-- Audio background nascosto -->
    <audio id="background-music" loop preload="auto">
        <source src="audio/background_music.mp3" type="audio/mp3">
    </audio>
    
    <!-- Audio hurry-up per la scelta vocale -->
    <audio id="hurry-up-sound" preload="auto">
        <source src="audio/hurry-up.mp3" type="audio/mp3">
    </audio>
    
    <!-- Audio per l'esplosione del tetramino -->
    <audio id="explode-sound" preload="auto">
        <source src="audio/explode.mp3" type="audio/mp3">
    </audio>
    
<script>
    // Riduzione di una riga: ROWS passa da 20 a 19
    const COLS = 10, ROWS = 19, START_DROP = 900, VOWEL_TIMEOUT = 3000, CHOICE_PROBABILITY = 0.3, ANIMATION_CLEAR_DURATION = 500;
    
    // --- Sistema audio semplificato ---
    const AudioSystem = {
        audioContext: null,
        backgroundMusic: document.getElementById('background-music'),
        hurryUpSound: document.getElementById('hurry-up-sound'),
        explodeSound: document.getElementById('explode-sound'),
        sfxGainNode: null,
        backgroundMusicActive: true,
        backgroundMusicLoaded: false,
        
        // Impostazioni suoni
        sounds: {
            drop: { freqs: [220, 165], durations: [0.05, 0.1] },
            selectVowel: { freqs: [440, 660], durations: [0.1, 0.1] },
            selectConsonant: { freqs: [550, 330], durations: [0.1, 0.1] },
            word: { freqs: [440, 493, 523, 587], durations: [0.08, 0.08, 0.08, 0.2] },
            bombExplosion: { 
                custom: true, 
                generate: function(audioContext, gainNode) {
                    const duration = 1.2;
                    const now = audioContext.currentTime;
                    
                    // Suono 1: Boom basso
                    const boom = audioContext.createOscillator();
                    const boomGain = audioContext.createGain();
                    boom.type = 'sawtooth';
                    boom.frequency.setValueAtTime(120, now);
                    boom.frequency.exponentialRampToValueAtTime(30, now + 0.8);
                    boomGain.gain.setValueAtTime(0.01, now);
                    boomGain.gain.exponentialRampToValueAtTime(0.7, now + 0.05);
                    boomGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    boom.connect(boomGain);
                    boomGain.connect(gainNode);
                    boom.start(now);
                    boom.stop(now + duration);
                    
                    // Suono 2: Rumore esplosione
                    const bufferSize = audioContext.sampleRate * 1.5;
                    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    
                    // Generazione del rumore bianco
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    
                    // Suono "scoppio"
                    const noise = audioContext.createBufferSource();
                    const noiseGain = audioContext.createGain();
                    const noiseFilter = audioContext.createBiquadFilter();
                    
                    noise.buffer = noiseBuffer;
                    noiseFilter.type = 'lowpass';
                    noiseFilter.frequency.setValueAtTime(8000, now);
                    noiseFilter.frequency.exponentialRampToValueAtTime(800, now + 0.6);
                    noiseGain.gain.setValueAtTime(0.01, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.25, now + 0.05);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(gainNode);
                    
                    noise.start(now);
                    noise.stop(now + duration);
                    
                    // Suono 3: Riverbero post-esplosione
                    setTimeout(() => {
                        const reverb = audioContext.createOscillator();
                        const reverbGain = audioContext.createGain();
                        const reverbFilter = audioContext.createBiquadFilter();
                        
                        reverb.type = 'sine';
                        reverb.frequency.setValueAtTime(400, now + 0.1);
                        reverb.frequency.exponentialRampToValueAtTime(100, now + 1.0);
                        
                        reverbFilter.type = 'bandpass';
                        reverbFilter.frequency.value = 200;
                        reverbFilter.Q.value = 3;
                        
                        reverbGain.gain.setValueAtTime(0.05, now + 0.1);
                        reverbGain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
                        
                        reverb.connect(reverbFilter);
                        reverbFilter.connect(reverbGain);
                        reverbGain.connect(gainNode);
                        
                        reverb.start(now + 0.1);
                        reverb.stop(now + duration);
                    }, 100);
                }
            }
        },
        
        initialize() {
            try {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Crea il nodo di guadagno per effetti sonori
                    this.sfxGainNode = this.audioContext.createGain();
                    this.sfxGainNode.gain.value = 0.7; // Volume SFX al 70%
                    this.sfxGainNode.connect(this.audioContext.destination);
                    
                    // Gestione della musica di sottofondo
                    this.initBackgroundMusic();
                    
                    // Inizializza i controlli dell'interfaccia
                    this.setupUIControls();
                }
                console.log("Sistema audio inizializzato");
            } catch (e) {
                console.error("Errore inizializzazione audio:", e);
            }
        },
        
        setupUIControls() {
            // Toggle musica
            const musicToggle = document.getElementById('toggle-music');
            if (musicToggle) {
                musicToggle.addEventListener('click', () => {
                    this.toggleBackgroundMusic();
                    musicToggle.textContent = this.backgroundMusicActive ? 'Musica: ON' : 'Musica: OFF';
                    musicToggle.className = this.backgroundMusicActive ? 'active' : '';
                });
            }
        },
        
        initBackgroundMusic() {
            if (!this.backgroundMusic) {
                console.error("Elemento audio per la musica di sottofondo non trovato");
                return;
            }
            
            // Mostra indicatore di caricamento
            const loadingIndicator = document.getElementById('audio-loading');
            
            // Imposta il volume a un valore più basso (20%)
            this.backgroundMusic.volume = 0.2;
            
            // Gestisci eventi di caricamento audio
            this.backgroundMusic.addEventListener('canplaythrough', () => {
                console.log("Musica di sottofondo caricata");
                this.backgroundMusicLoaded = true;
                
                if (loadingIndicator) {
                    loadingIndicator.classList.add('hidden');
                }
                
                // Avvia la riproduzione se attivo
                if (this.backgroundMusicActive) {
                    this.playBackgroundMusic();
                }
            });
            
            this.backgroundMusic.addEventListener('error', (e) => {
                console.error("Errore caricamento musica di sottofondo:", e);
                if (loadingIndicator) {
                    loadingIndicator.textContent = "Errore caricamento musica";
                    setTimeout(() => {
                        loadingIndicator.classList.add('hidden');
                    }, 3000);
                }
            });
            
            // Gestione dell'aggiornamento dell'elemento audio
            if (this.backgroundMusic.networkState === 1) {
                // Già caricato
                this.backgroundMusicLoaded = true;
                if (loadingIndicator) loadingIndicator.classList.add('hidden');
                if (this.backgroundMusicActive) this.playBackgroundMusic();
            }
        },
        
        playBackgroundMusic() {
            if (!this.backgroundMusic || !this.backgroundMusicLoaded) return;
            
            const playPromise = this.backgroundMusic.play();
            
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("Errore riproduzione musica di sottofondo:", error);
                });
            }
        },
        
        stopBackgroundMusic() {
            if (!this.backgroundMusic) return;
            this.backgroundMusic.pause();
        },
        
        toggleBackgroundMusic() {
            this.backgroundMusicActive = !this.backgroundMusicActive;
            
            if (this.backgroundMusicActive) {
                this.playBackgroundMusic();
            } else {
                this.stopBackgroundMusic();
            }
        },
        
        playHurryUp() {
            if (!this.hurryUpSound) {
                console.error("Elemento audio per il suono hurry-up non trovato");
                return;
            }
            
            try {
                // Resetta il suono se stava già suonando
                this.hurryUpSound.pause();
                this.hurryUpSound.currentTime = 0;
                
                // Imposta volume al 70%
                this.hurryUpSound.volume = 0.7;
                
                // Riproduci il suono
                const playPromise = this.hurryUpSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn("Errore riproduzione suono hurry-up:", error);
                    });
                }
            } catch (e) {
                console.error("Errore riproduzione hurry-up:", e);
            }
        },
        
        stopHurryUp() {
            if (!this.hurryUpSound) return;
            
            try {
                this.hurryUpSound.pause();
                this.hurryUpSound.currentTime = 0;
            } catch (e) {
                console.error("Errore arresto hurry-up:", e);
            }
        },
        
        playExplode() {
            if (!this.explodeSound) {
                console.error("Elemento audio per il suono explode non trovato");
                return;
            }
            
            try {
                // Resetta il suono se stava già suonando
                this.explodeSound.pause();
                this.explodeSound.currentTime = 0;
                
                // Imposta volume al 70%
                this.explodeSound.volume = 0.7;
                
                // Riproduci il suono
                const playPromise = this.explodeSound.play();
                
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn("Errore riproduzione suono explode:", error);
                    });
                }
            } catch (e) {
                console.error("Errore riproduzione explode:", e);
            }
        },
        
        playSynthSound(type) {
            try {
                if (!this.audioContext) this.initialize();
                
                const soundData = this.sounds[type];
                if (!soundData) return;
                
                // Feedback visivo
                const indicator = document.getElementById('sound-indicator');
                if (indicator) {
                    indicator.textContent = `♪ ${type}`;
                    indicator.classList.add('active');
                    setTimeout(() => indicator.classList.remove('active'), 1000);
                }
                
                // Se abbiamo un suono custom, usa il generatore dedicato
                if (soundData.custom&&typeof soundData.generate === 'function') {
                    soundData.generate(this.audioContext, this.sfxGainNode);
                    return;
                }
                
                // Altrimenti usa il generatore standard
                let startTime = this.audioContext.currentTime;
                
                for (let i = 0; i < soundData.freqs.length; i++) {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.type = type === 'bombExplosion' ? 'sawtooth' : 'sine';
                    oscillator.frequency.value = soundData.freqs[i];
                    
                    gainNode.gain.setValueAtTime(0.001, startTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.3, startTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + soundData.durations[i]);
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.sfxGainNode);
                    
                    oscillator.start(startTime);
                    oscillator.stop(startTime + soundData.durations[i]);
                    
                    startTime += soundData.durations[i];
                }
            } catch (e) {
                console.error(`Errore riproduzione suono sintetizzato ${type}:`, e);
            }
        },
        
        playSound(type) {
            // Assicurati che AudioContext sia pronto
            if (!this.audioContext) this.initialize();
            
            // Riproduci il suono sintetizzato
            this.playSynthSound(type);
        }
    };
    
    // Funzione di utilità per riprodurre i suoni
    function playSound(soundType) {
        AudioSystem.playSound(soundType);
    }
    
    // --- Dati di gioco ---
    const VOWELS = ["A", "E", "I", "O", "U"];
    const CONSONANTS = ["B", "C", "D", "F", "G", "H", "L", "M", "N", "P", "Q", "R", "S", "T", "V", "Z"];
    const SYLS_1_LETTER = ["A", "E", "I", "O", "U"]; 
    const SYLS_2_LETTERS = [ 
        "PA", "RA", "MA", "NO", "SO", "LA", "MO", "NE", "LI", "PE", "RE", "TI", "CA", "SA", "LO", "MI", "CI", "VA",
        "LE", "RI", "ME", "TE", "BO", "DO", "NA", "BI", "CO", "DA", "DI", "FA", "FE", "FI", "FO", "FU", "GA", "GE",
        "GI", "NI", "PI", "PO", "PU", "RO", "RU", "SE", "SI", "SU", "TA", 
        "TO", "VI", "VO", "DE", "BA", "CE" 
    ]; 
    const SYLS_3_LETTERS = [ 
        "PER", "TOR", "MAN", "CAN", "STR", "PRE", "GRA", "CES", "COS", "DAL", "DEL", "FRA", 
        "GIA", "GLI", "NON", "PAR", "PIO", "PIU", "PRI", "PRO", "QUA", "QUE", "QUI", "SCA", "SCE",
        "SCI", "STA", "STE", "STI", "STO", "TRA", "TRE", "TRI", "TRO", "VER", "VOL", "ZIO", "CAR",
        "TER", "MEN", "SEN", "CON", "ENT", "INT", "CIO", "CIA"
    ]; 
    const PROB_ONE_LETTER_SYL = 0.15; 
    const PROB_THREE_LETTER_SYL = 0.20;
    // NUOVE COSTANTI:
    const VOWEL_CHOICE_PROBABILITY = 0.3;
    const CONSONANT_CHOICE_PROBABILITY = 0.2;
    // Numero di consonanti da mostrare alla volta per la selezione
    const NUM_CONSONANT_CHOICES = 5;

    const DICT = new Set();
    let dizionarioPronto = false;
    const gameElement = document.getElementById("game");
    for (let i = 0; i < ROWS * COLS; i++) { const d = document.createElement("div"); d.className = "cell"; gameElement.appendChild(d); }
    const $ = q => document.querySelectorAll("#game .cell")[q];
    const idx = (x, y) => (y * COLS + x);

    let board, cur, gameLoopTimer, choiceTimerId, score = 0, words = 0, pieces = 0, gameIsOver = false, isChoiceActive = false;
    let isVowelChoice = false; // true per vocali, false per consonanti
    let choiceCellInfo = null;
    let isAnimatingClear = false; 
    let pendingBoardUpdateAfterAnimation = false;
    let isNextPieceBomb = false; 
    let bombPower = 0;      
    let currentDropInterval = START_DROP; 
    let chainCount = 0;     
    let currentChainMultiplier = 1.0;  
    let isHurryUpPlaying = false;  
    let timerInterval = null;
    // Le consonanti attualmente disponibili per la scelta
    let availableConsonants = [];

    const ui = { 
        s: document.getElementById("score"), 
        w: document.getElementById("words"), 
        p: document.getElementById("pieces"), 
        vowelSelection: document.getElementById("vowel-selection"),
        consonantSelection: document.getElementById("consonant-selection"),
        lastWordVal: document.getElementById("last-word-val"),
        vowelTimerContainer: document.getElementById("vowel-timer-container"),
        vowelTimer: document.getElementById("vowel-timer"),
        consonantTimerContainer: document.getElementById("consonant-timer-container"),
        consonantTimer: document.getElementById("consonant-timer")
    };

    function randSyl() {
        const rand = Math.random();
        
        if (rand < PROB_ONE_LETTER_SYL) {
            return SYLS_1_LETTER[Math.floor(Math.random() * SYLS_1_LETTER.length)];
        }
        else if (rand < PROB_ONE_LETTER_SYL + PROB_THREE_LETTER_SYL) {
            if (SYLS_3_LETTERS.length > 0) {
                return SYLS_3_LETTERS[Math.floor(Math.random() * SYLS_3_LETTERS.length)];
            }
        }
        
        if (SYLS_2_LETTERS.length > 0) {
            return SYLS_2_LETTERS[Math.floor(Math.random() * SYLS_2_LETTERS.length)];
        } else if (SYLS_3_LETTERS.length > 0) { 
            return SYLS_3_LETTERS[Math.floor(Math.random() * SYLS_3_LETTERS.length)];
        } else if (SYLS_1_LETTER.length > 0) {
            return SYLS_1_LETTER[Math.floor(Math.random() * SYLS_1_LETTER.length)];
        } else {
            console.error("ERRORE: Tutte le liste di sillabe sono vuote!");
            return "??"; 
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function selectRandomConsonants() {
        // Crea una copia delle consonanti e mischiala
        const shuffledConsonants = shuffleArray([...CONSONANTS]);
        
        // Scegli le prime NUM_CONSONANT_CHOICES consonanti
        return shuffledConsonants.slice(0, NUM_CONSONANT_CHOICES);
    }

    function setupConsonantSelection() {
        // Seleziona le consonanti casuali
        availableConsonants = selectRandomConsonants();
        
        // Ottieni il container di selezione delle consonanti
        const consonantSelection = document.getElementById("consonant-selection");
        
        // Rimuovi tutti i bottoni delle consonanti esistenti
        const buttons = consonantSelection.querySelectorAll('.consonant');
        buttons.forEach(button => button.remove());
        
        // Crea i nuovi bottoni con le consonanti selezionate
        availableConsonants.forEach(consonant => {
            const button = document.createElement('div');
            button.className = 'consonant';
            button.setAttribute('data-consonant', consonant);
            button.textContent = consonant;
            button.addEventListener('click', e => {
                if (isChoiceActive&&!isVowelChoice) {
                    resolveChoice(e.target.getAttribute('data-consonant'));
                }
            });
            consonantSelection.appendChild(button);
        });
    }

    function newPiece() {
        if (isNextPieceBomb) {
            isNextPieceBomb = false; 
            pieces++; ui.p.textContent = pieces;
            return { x: COLS >> 1, y: -1, h: 1, txt: ["💣"], isBomb: true, power: bombPower };
        }
        const r = Math.random(), h_normal = r < .3 ? 1 : r < .75 ? 2 : 3; const txt = [];
        while(txt.length < h_normal) { const s = randSyl(); if (!txt.includes(s)) txt.push(s); }
        pieces++; ui.p.textContent = pieces;
        
        if (txt.length > 0) {
            const sylIndexToMakeJoker = txt.length - 1; 
            const originalSyl = txt[sylIndexToMakeJoker];
            
            // Verifica se rendere un jolly di vocale
            if (/[AEIOU]$/.test(originalSyl)&&originalSyl.length > 1&&Math.random() < VOWEL_CHOICE_PROBABILITY) { 
                txt[sylIndexToMakeJoker] = originalSyl.slice(0, -1) + "*";
            }
            // Verifica se rendere un jolly di consonante (solo per vocali singole)
            else if (VOWELS.includes(originalSyl)&&Math.random() < CONSONANT_CHOICE_PROBABILITY) {
                txt[sylIndexToMakeJoker] = "*" + originalSyl;
            }
        }
        
        return { x: COLS >> 1, y: -h_normal, h: txt.length, txt, isBomb: false };
    }

    function canMove(p, dx, dy) {
        if (!p || isAnimatingClear) return false;
        for (let i = 0; i < p.h; i++) {
            const nx = p.x + dx, ny = p.y + i + dy;
            if (nx < 0 || nx >= COLS || ny >= ROWS || (ny >= 0&&board[ny][nx]&&board[ny][nx] !== 'CLEARING_PLACEHOLDER')) return false;
        }
        return true;
    }

    function lockCurrentPiece() { 
        if (!dizionarioPronto || isAnimatingClear) return;
        clearInterval(gameLoopTimer); 

        playSound('drop');

        if (cur.isBomb) {
            let landingRow = cur.y + cur.h - 1; 
            for(let i = cur.h -1; i >= 0; i--){ 
                if(cur.y + i >= ROWS -1 || (cur.y + i + 1 < ROWS&&board[cur.y + i + 1]&&board[cur.y + i + 1][cur.x])) { 
                    landingRow = cur.y + i; break;
                }
            }
            if (landingRow >= ROWS) landingRow = ROWS -1; 
            
            playSound('bombExplosion');
            
            detonateBomb(landingRow, cur.power, cur.x); 
            cur = null;
            processBoardAfterLock(); 
            return; 
        }

        let needsVowelChoice = false;
        let needsConsonantChoice = false;
        choiceCellInfo = null;
        
        for (let i = 0; i < cur.h; i++) {
            const r_lock = cur.y + i, c_lock = cur.x;
            if (r_lock < 0) { draw(); handleGameOver(); return; }
            board[r_lock][c_lock] = cur.txt[i];
        }
        
        for (let i = 0; i < cur.h; i++) {
            const r_check = cur.y + i, c_check = cur.x;
            if (r_check >= 0) {
                const cellContent = cur.txt[i];
                
                // Controlla i jolly di vocale (con * alla fine, es: "T*")
                if (cellContent.endsWith("*")) {
                    needsVowelChoice = true;
                    isVowelChoice = true;
                    choiceCellInfo = { r: r_check, c: c_check, prefix: cellContent.slice(0, -1) };
                    break;
                }
                // Controlla i jolly di consonante (con * all'inizio, es: "*A")
                else if (cellContent.startsWith("*")&&cellContent.length > 1) {
                    needsConsonantChoice = true;
                    isVowelChoice = false;
                    choiceCellInfo = { r: r_check, c: c_check, suffix: cellContent.slice(1) };
                    
                    // Prepara le consonanti disponibili per la selezione
                    setupConsonantSelection();
                    break;
                }
            }
        }
        
        cur = null; 
        draw(); 
        
        if (needsVowelChoice || needsConsonantChoice) {
            AudioSystem.playHurryUp();
            isHurryUpPlaying = true;
            
            isChoiceActive = true;
            
            if (needsVowelChoice) {
                ui.vowelSelection.style.display = "block";
                startTimer(true);
                document.addEventListener('keydown', handleVowelKeyboardChoice);
            } else {
                ui.consonantSelection.style.display = "block";
                startTimer(false);
                document.addEventListener('keydown', handleConsonantKeyboardChoice);
            }
            
            clearTimeout(choiceTimerId);
            choiceTimerId = setTimeout(() => resolveChoice(null), VOWEL_TIMEOUT);
        } else {
            processBoardAfterLock();
        }
    }
    
    function startTimer(isVowel) {
        const container = isVowel ? ui.vowelTimerContainer : ui.consonantTimerContainer;
        const timer = isVowel ? ui.vowelTimer : ui.consonantTimer;
        
        container.style.display = "block";
        timer.style.width = "100%";
        timer.style.transition = `width ${VOWEL_TIMEOUT/1000}s linear`;
        
        void timer.offsetWidth;
        
        timer.style.width = "0%";
    }
    
    function stopTimers() {
        ui.vowelTimerContainer.style.display = "none";
        ui.vowelTimer.style.transition = "none";
        ui.vowelTimer.style.width = "100%";
        
        ui.consonantTimerContainer.style.display = "none";
        ui.consonantTimer.style.transition = "none";
        ui.consonantTimer.style.width = "100%";
    }

    function detonateBomb(bombHitRow, numRowsToClear, bombCol) {
        if (numRowsToClear <= 0) return;
        let actualRowsCleared = 0;
        for (let i = 0; i < numRowsToClear; i++) {
            const rowToClear = bombHitRow - i; 
            if (rowToClear >= 0&&rowToClear < ROWS) {
                for (let c = 0; c < COLS; c++) board[rowToClear][c] = null; 
                actualRowsCleared++; score += 50 * (i + 1); 
            } else break; 
        }
    }

    function handleVowelKeyboardChoice(e) {
        if (!isChoiceActive || !isVowelChoice) return;
        const keyPressed = e.key.toUpperCase();
        if (VOWELS.includes(keyPressed)) {
            e.preventDefault();
            resolveChoice(keyPressed);
        }
    }
    
    function handleConsonantKeyboardChoice(e) {
        if (!isChoiceActive || isVowelChoice) return;
        const keyPressed = e.key.toUpperCase();
        if (availableConsonants.includes(keyPressed)) {
            e.preventDefault();
            resolveChoice(keyPressed);
        }
    }

    document.querySelectorAll('.vowel').forEach(el => {
        el.addEventListener('click', e => {
            if (isChoiceActive&&isVowelChoice) {
                resolveChoice(e.target.getAttribute('data-vowel'));
            }
        });
    });

    function resolveChoice(chosenLetter) {
        if (!isChoiceActive) return;
        clearTimeout(choiceTimerId);
        
        if (isVowelChoice) {
            document.removeEventListener('keydown', handleVowelKeyboardChoice);
            ui.vowelSelection.style.display = "none";
        } else {
            document.removeEventListener('keydown', handleConsonantKeyboardChoice);
            ui.consonantSelection.style.display = "none";
        }
        
        isChoiceActive = false;
        stopTimers();
        
        if (isHurryUpPlaying) {
            AudioSystem.stopHurryUp();
            isHurryUpPlaying = false;
        }
        
        if (!chosenLetter&&choiceCellInfo) {
            AudioSystem.playExplode();
            
            const { r, c } = choiceCellInfo;
            
            if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c]) {
                const cellContent = board[r][c];
                const isJollyVowel = cellContent.endsWith("*");
                const isJollyConsonant = cellContent.startsWith("*");
                
                if (isJollyVowel || isJollyConsonant) {
                    isAnimatingClear = true;
                    
                    const cellElement = $(idx(c, r));
                    if (cellElement) {
                        cellElement.classList.add('clearing');
                        board[r][c] = 'CLEARING_PLACEHOLDER';
                        
                        const jollyType = isJollyVowel ? "VOCALE" : "CONSONANTE";
                        ui.lastWordVal.innerHTML = `<span style="color:#f55">JOLLY ${jollyType} DISINTEGRATO!</span>`;
                        
                        setTimeout(() => {
                            if (board[r]&&board[r][c] === 'CLEARING_PLACEHOLDER') board[r][c] = null;
                            if (cellElement) {
                                cellElement.classList.remove('clearing');
                                cellElement.textContent = "";
                                cellElement.className = "cell";
                            }
                            isAnimatingClear = false;
                            processBoardAfterLock();
                        }, ANIMATION_CLEAR_DURATION);
                    }
                } else {
                    processBoardAfterLock();
                }
            } else {
                processBoardAfterLock();
            }
        } else if (chosenLetter&&choiceCellInfo) {
            if (isVowelChoice) {
                const { r, c, prefix } = choiceCellInfo;
                if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c] === prefix + "*") {
                    board[r][c] = prefix + chosenLetter;
                }
            } else { // Consonant choice
                const { r, c, suffix } = choiceCellInfo;
                if (r >= 0&&r < ROWS&&c >= 0&&c < COLS&&board[r]&&board[r][c] === "*" + suffix) {
                    board[r][c] = chosenLetter + suffix;
                }
            }
            
            choiceCellInfo = null;
            draw();
            processBoardAfterLock();
        } else {
            choiceCellInfo = null;
            draw();
            processBoardAfterLock();
        }
    }

    function processBoardAfterLock() {
        if (!dizionarioPronto || gameIsOver) return; 
        if (isAnimatingClear) return; 
        
        pendingBoardUpdateAfterAnimation = false;
        let iterations = 0; const MAX_ITERATIONS = ROWS * COLS; 
        let stabilityReached = false;
        let wordFoundThisOverallPBALCycle = false;

        while (iterations < MAX_ITERATIONS&&!stabilityReached&&!gameIsOver&&!isAnimatingClear) {
            iterations++;
            if (gameIsOver) break;
            collapse(); draw();
            if (isAnimatingClear) break; 

            let wordFoundThisScanPass = false; 
            if (scanAndClearHorizontalWords()) { wordFoundThisScanPass = true; wordFoundThisOverallPBALCycle = true; }
            if (isAnimatingClear || gameIsOver) break;

            if (scanAndClearVerticalWords()) { wordFoundThisScanPass = true; wordFoundThisOverallPBALCycle = true; }
            if (isAnimatingClear || gameIsOver) break;

            if (!wordFoundThisScanPass) stabilityReached = true; 
        } 
        
        if (!isAnimatingClear&&!gameIsOver) {
            ui.s.textContent = score; ui.w.textContent = words;
            cur = newPiece(); 
            
            if (cur.isBomb) { 
                currentDropInterval = Math.floor(START_DROP / 3);
            } else { 
                currentDropInterval = START_DROP;
            }

            if (!canMove(cur, 0, 0)) { draw(); handleGameOver(); return; }
            draw();
            if (!gameIsOver) {
                clearInterval(gameLoopTimer); 
                gameLoopTimer = setInterval(gameStep, currentDropInterval); 
            }
        }
    }

    function scanAndClearHorizontalWords() {
        if (gameIsOver || isAnimatingClear) return false; let clearedAny = false;
        for (let r = 0; r < ROWS; r++) {
            let currentRun = [];
            for (let c = 0; c < COLS; c++) {
                const cellContent = board[r][c];
                // Modifica per escludere sia i jolly di vocale che quelli di consonante
                if (cellContent&&!cellContent.endsWith("*")&&!cellContent.startsWith("*")&&cellContent !== 'CLEARING_PLACEHOLDER') {
                    currentRun.push({syl: cellContent, c: c });
                } else { 
                    if (currentRun.length >= 2&&processRunForWords(currentRun, r, true)) clearedAny = true;
                    currentRun = []; 
                }
                if (isAnimatingClear) break; 
            }
            if (isAnimatingClear) break;
            if (currentRun.length >= 2&&processRunForWords(currentRun, r, true)) clearedAny = true;
        }
        return clearedAny;
    }

    function scanAndClearVerticalWords() {
        if (gameIsOver || isAnimatingClear) return false; let clearedAny = false;
        for (let c = 0; c < COLS; c++) {
            let currentRun = [];
            for (let r = 0; r < ROWS; r++) {
                const cellContent = board[r][c];
                // Modifica per escludere sia i jolly di vocale che quelli di consonante
                if (cellContent&&!cellContent.endsWith("*")&&!cellContent.startsWith("*")&&cellContent !== 'CLEARING_PLACEHOLDER') {
                    currentRun.push({syl: cellContent, r: r });
                } else { 
                    if (currentRun.length >= 2&&processRunForWords(currentRun, c, false)) clearedAny = true; 
                    currentRun = []; 
                }
                if (isAnimatingClear) break;
            }
            if (isAnimatingClear) break;
            if (currentRun.length >= 2&&processRunForWords(currentRun, c, false)) clearedAny = true;
        }
        return clearedAny;
    }

    function processRunForWords(run, fixedCoord, isHorizontal) {
        if (gameIsOver || isAnimatingClear) return false;
        for (let len = run.length; len >= 2; len--) {
            for (let i = 0; i <= run.length - len; i++) {
                const subRun = run.slice(i, i + len); const wordAttempt = subRun.map(item => item.syl).join("");
                if (DICT.has(wordAttempt)) {
                    let cellsAreValid = true;
                    for(const item of subRun) { const r_val = isHorizontal ? fixedCoord : item.r; const c_val = isHorizontal ? item.c : fixedCoord; if(!board[r_val] || board[r_val][c_val] !== item.syl || board[r_val][c_val] === 'CLEARING_PLACEHOLDER') { cellsAreValid = false; break; }}
                    if(cellsAreValid) {
                        playSound('word');
                        
                        isAnimatingClear = true; clearInterval(gameLoopTimer);
                        const cellsToAnimate = [];
                        for (const item of subRun) { const r_anim = isHorizontal ? fixedCoord : item.r; const c_anim = isHorizontal ? item.c : fixedCoord; const cellElement = $(idx(c_anim, r_anim)); if (cellElement) { cellElement.classList.add('clearing'); cellsToAnimate.push({ r:r_anim, c:c_anim }); board[r_anim][c_anim] = 'CLEARING_PLACEHOLDER'; }}
                        
                        const numberOfSyllablesInGrid = subRun.length;
                        let bombaAttivataQuestoTurno = false;
                        if (numberOfSyllablesInGrid >= 3&&!isNextPieceBomb) { 
                            isNextPieceBomb = true;
                            bombPower = numberOfSyllablesInGrid - 2;
                            bombaAttivataQuestoTurno = true;
                        }
                        score += wordAttempt.length * 10; words++;
                        if (bombaAttivataQuestoTurno) {
                            ui.lastWordVal.innerHTML = wordAttempt + `<br><span style="color:orange;font-weight:bold;">BOMBA PRONTA! (${bombPower} righe)</span>`;
                        } else {
                            ui.lastWordVal.textContent = wordAttempt;
                        }
                        
                        setTimeout(() => {
                            cellsToAnimate.forEach(cellCoords => { if (board[cellCoords.r]&&board[cellCoords.r][cellCoords.c] === 'CLEARING_PLACEHOLDER') board[cellCoords.r][cellCoords.c] = null; const el = $(idx(cellCoords.c, cellCoords.r)); if (el) { el.classList.remove('clearing'); el.textContent = ""; el.className = "cell"; }});
                            isAnimatingClear = false; pendingBoardUpdateAfterAnimation = true;
                            if (!gameIsOver) processBoardAfterLock(); else draw(); 
                        }, ANIMATION_CLEAR_DURATION);
                        return true; 
                    }
                }
            }
        }
        return false;
    }

    function collapse() {
        if (gameIsOver || isAnimatingClear) return;
        for (let c = 0; c < COLS; c++) {
            let emptyRow = ROWS - 1;
            for (let r = ROWS - 1; r >= 0; r--) {
                const cellContent = board[r][c];
                if (cellContent&&cellContent !== 'CLEARING_PLACEHOLDER') {
                    if (r !== emptyRow) { board[emptyRow][c] = board[r][c]; board[r][c] = null; }
                    emptyRow--;
                }
            }
        }
    }

    function draw() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cellElement = $(idx(c, r));
                if (cellElement) {
                    const s_board = board[r][c];
                    if (s_board === 'CLEARING_PLACEHOLDER') { if(!cellElement.classList.contains('clearing')) {} continue; }
                    cellElement.textContent = s_board || "";
                    if (s_board) {
                        if (s_board === "💣") { 
                            cellElement.className = "cell bomb-cell";
                        } else if (s_board.endsWith("*")) {
                            cellElement.className = "cell joker-cell";
                        } else if (s_board.startsWith("*")) {
                            cellElement.className = "cell consonant-joker-cell";
                        } else {
                            cellElement.className = "cell filled";
                        }
                    } else {
                        cellElement.className = "cell";
                    }
                }
            }
        }
        if (cur&&!gameIsOver&&!isAnimatingClear) {
            cur.txt.forEach((s_cur, i) => {
                const r_cur = cur.y + i;
                if (r_cur >= 0&&r_cur < ROWS) {
                    const cellElement = $(idx(cur.x, r_cur));
                    if (cellElement) { 
                        if (board[r_cur]&&board[r_cur][cur.x] === 'CLEARING_PLACEHOLDER') return;
                        cellElement.textContent = s_cur; 
                        if (cur.isBomb) { 
                            cellElement.className = "cell bomb-cell";
                        } else if (s_cur.endsWith("*")) { 
                            cellElement.className = "cell joker-cell";
                        } else if (s_cur.startsWith("*")) {
                            cellElement.className = "cell consonant-joker-cell";
                        } else { 
                            cellElement.className = "cell filled";
                        }
                    }
                }
            });
        }
    }

    function gameStep() {
        if (isChoiceActive || gameIsOver || !cur || !dizionarioPronto || isAnimatingClear) return;
        if (canMove(cur, 0, 1)) cur.y++; else lockCurrentPiece(); 
        if (cur&&!gameIsOver&&!isAnimatingClear) draw();
    }

    function handleMove(direction) {
        if (isChoiceActive || gameIsOver || !cur || !dizionarioPronto || isAnimatingClear) return;
        
        let moved = false;
        const currentPieceCells = [];
        
        if (cur.isBomb) { 
            if (direction === 'left'&&canMove(cur, -1, 0)) { cur.x--; moved = true; }
            else if (direction === 'right'&&canMove(cur, 1, 0)) { cur.x++; moved = true; }
            else if (direction === 'down'&&canMove(cur, 0, 1)) { cur.y++; moved = true; }
        } else { 
            if (direction === 'left'&&canMove(cur, -1, 0)) { cur.x--; moved = true; }
            else if (direction === 'right'&&canMove(cur, 1, 0)) { cur.x++; moved = true; }
            else if (direction === 'down'&&canMove(cur, 0, 1)) { cur.y++; moved = true; } 
            else if (direction === 'rotate'&&cur.txt.length > 1) { cur.txt.unshift(cur.txt.pop()); moved = true; }
        }

        if(moved&&!gameIsOver&&!isAnimatingClear) {
            cur.txt.forEach((s_cur, i) => { 
                const r_cur = cur.y + i; 
                if (r_cur >= 0&&r_cur < ROWS) { 
                    const cellElement = $(idx(cur.x, r_cur)); 
                    if (cellElement&&(!board[r_cur] || board[r_cur][cur.x] !== 'CLEARING_PLACEHOLDER')) 
                        currentPieceCells.push(cellElement); 
                }
            });
            
            currentPieceCells.forEach(el => el.classList.add('piece-moved-feedback'));
            draw();
            setTimeout(() => currentPieceCells.forEach(el => el.classList.remove('piece-moved-feedback')), 100);
        }
    }

    function setupTouchControls() {
        document.body.addEventListener('touchmove', (e) => {
            if (e.target.closest('#touch-controls')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.getElementById('touch-left').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('left');
            startRepeatMove('left');
        });
        
        document.getElementById('touch-right').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('right');
            startRepeatMove('right');
        });
        
        document.getElementById('touch-down').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('down');
            startRepeatMove('down');
        });
        
        document.getElementById('touch-rotate').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleMove('rotate');
        });
        
        const touchButtons = document.querySelectorAll('.touch-button');
        touchButtons.forEach(button => {
            button.addEventListener('touchend', stopRepeatMove);
            button.addEventListener('touchcancel', stopRepeatMove);
        });
    }
    
    let repeatMoveTimer = null;
    
    function startRepeatMove(direction) {
        stopRepeatMove();
        repeatMoveTimer = setInterval(() => {
            handleMove(direction);
        }, 150);
    }
    
    function stopRepeatMove() {
        if (repeatMoveTimer) {
            clearInterval(repeatMoveTimer);
            repeatMoveTimer = null;
        }
    }

    document.addEventListener("keydown", e => {
        const activeElement = document.activeElement;
        if (activeElement&&(activeElement.id === 'music-volume' || activeElement.id === 'sfx-volume')) {
            if (e.code === "ArrowLeft" || e.code === "ArrowRight" || 
                e.code === "ArrowUp" || e.code === "ArrowDown") {
                activeElement.blur();
            }
        }
        
        if (e.code === "ArrowLeft") handleMove('left');
        else if (e.code === "ArrowRight") handleMove('right');
        else if (e.code === "ArrowDown") handleMove('down');
        else if (e.code === "ArrowUp") handleMove('rotate');
    });

    function initializeActualGame() {
        if (!dizionarioPronto) { console.error("InitializeActualGame: Dizionario non pronto."); return; }
        gameIsOver = false; isChoiceActive = false; isVowelChoice = false; isAnimatingClear = false; pendingBoardUpdateAfterAnimation = false;
        isNextPieceBomb = false; bombPower = 0; 
        chainCount = 0; currentChainMultiplier = 1.0; 
        isHurryUpPlaying = false;

        stopTimers();

        clearTimeout(choiceTimerId);
        if (document.activeElement&&typeof document.activeElement.blur === 'function') document.activeElement.blur();
        document.removeEventListener('keydown', handleVowelKeyboardChoice);
        document.removeEventListener('keydown', handleConsonantKeyboardChoice);
        ui.vowelSelection.style.display = "none";
        ui.consonantSelection.style.display = "none";
        
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        score = 0; words = 0; pieces = 0; ui.s.textContent = 0; ui.w.textContent = 0; ui.p.textContent = 0; ui.lastWordVal.textContent = "---";
        
        cur = newPiece(); 
        if (cur.isBomb) { 
            currentDropInterval = Math.floor(START_DROP / 3);
        } else { 
            currentDropInterval = START_DROP;
        }
        
        draw();
        clearInterval(gameLoopTimer);
        if (!isAnimatingClear&&!gameIsOver) { gameLoopTimer = setInterval(gameStep, currentDropInterval); }
        
        AudioSystem.initialize();
        setupTouchControls();
    }

    function handleGameOver() {
        if (gameIsOver) return; gameIsOver = true; 
        clearInterval(gameLoopTimer); clearTimeout(choiceTimerId);
        
        stopTimers();
        
        if (isHurryUpPlaying) {
            AudioSystem.stopHurryUp();
            isHurryUpPlaying = false;
        }
        
        if (isChoiceActive) { 
            document.removeEventListener('keydown', handleVowelKeyboardChoice);
            document.removeEventListener('keydown', handleConsonantKeyboardChoice);
            ui.vowelSelection.style.display = "none";
            ui.consonantSelection.style.display = "none";
            isChoiceActive = false;
        }
        draw(); 
        setTimeout(() => { alert(`GAME OVER\nPunti ${score}\nParole ${words}\nPezzi ${pieces}`); loadDictionaryAndInitGame(); }, 100 + (isAnimatingClear ? ANIMATION_CLEAR_DURATION : 0) );
    }

    async function loadDictionaryAndInitGame() {
        gameIsOver = false; isAnimatingClear = false; pendingBoardUpdateAfterAnimation = false; clearInterval(gameLoopTimer);
        DICT.clear(); dizionarioPronto = false; 
        ui.lastWordVal.textContent = "CARICAMENTO...";
        try {
            const response = await fetch('data/dizionario.txt');
            if (!response.ok) throw new Error(`Errore HTTP! Status: ${response.status} (${response.statusText}) per data/dizionario.txt`);
            const text = await response.text(); const paroleCaricate = text.trim().split(/\r?\n/);
            paroleCaricate.forEach(word => { const parolaPulita = word.trim().toUpperCase(); if (parolaPulita.length > 0) DICT.add(parolaPulita); });
            if (DICT.size === 0&&paroleCaricate.length > 0) console.warn("Dizionario caricato ma DICT è vuoto.");
            else if (DICT.size === 0) console.warn("Nessuna parola caricata nel dizionario.");
            dizionarioPronto = true; ui.lastWordVal.textContent = "---"; initializeActualGame();
        } catch (error) { console.error("Impossibile caricare il dizionario:", error); alert("Errore caricamento dizionario: " + error.message + "\nControlla console."); ui.lastWordVal.textContent = "ERRORE DIZIONARIO"; }
    }
    
    document.getElementById('start-game-button').addEventListener('click', function() {
        document.getElementById('audio-start-overlay').style.display = 'none';
        
        AudioSystem.backgroundMusicActive = true;
        AudioSystem.initialize();
        
        loadDictionaryAndInitGame();
    });
</script>
</body>
</html>